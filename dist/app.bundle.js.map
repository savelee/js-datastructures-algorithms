{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../node_modules/webpack/buildin/global.js-exposed","webpack:///./ts/datastructures/SimpleDict.ts-exposed","webpack:///./ts/datastructures/Stack.ts-exposed","webpack:///./ts/datastructures/Queue.ts-exposed","webpack:///./index.ts-exposed","webpack:///../node_modules/webpack/buildin/global.js","webpack:///./index.ts","webpack:///./ts/datastructures/Stack.ts","webpack:///./ts/datastructures/Queue.ts","webpack:///./ts/datastructures/LinkedList.ts-exposed","webpack:///./ts/datastructures/LinkedList.ts","webpack:///./ts/datastructures/Set.ts-exposed","webpack:///./ts/datastructures/Set.ts","webpack:///./ts/datastructures/Map.ts-exposed","webpack:///./ts/datastructures/Map.ts","webpack:///./ts/datastructures/HashTable.ts-exposed","webpack:///./ts/datastructures/HashTable.ts","webpack:///./ts/datastructures/SimpleDict.ts","webpack:///./ts/datastructures/Tree.ts-exposed","webpack:///./ts/datastructures/Tree.ts","webpack:///./ts/datastructures/Graph.ts-exposed","webpack:///./ts/datastructures/Graph.ts","webpack:///./ts/algorithms/Sorters.ts-exposed","webpack:///./ts/algorithms/Sorters.ts","webpack:///./ts/algorithms/Searchers.ts-exposed","webpack:///./ts/algorithms/Searchers.ts","webpack:///./ts/hackerrank/TwoStrings.ts-exposed","webpack:///./ts/hackerrank/TwoStrings.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","global","g","this","Function","e","window","Stack_1","Queue_1","LinkedList_1","Set_1","Map_1","HashTable_1","Tree_1","Graph_1","SimpleDict_1","Sorters_1","Searchers_1","TwoStrings_1","Stack","Queue","LinkedList","Set","Map","HashTable","BinarySearchTree","Graph","SimpleDict","Sorters","Searchers","SubStringSet","[object Object]","items","total","item","undefined","isEmpty","count","length","Node","node","next","head","last_node","getHead","setHead","index","isInserted","size","newNode","previous","getNodeAt","current","indexOf","removeAt","isRemoved","arr","push","isCreated","has","isExisting","parseInt","callback","otherSet","unionSet","forEach","val","set","add","intersection","difference","isSubset","counter","hasKey","toString","opt","table","bucketSize","probe","uniqueKeys","hash","hashCode","hasHash","keys","console","error","constructor","newItem","remove","itemValue","charCodeAt","values","TreeNode","left","right","root","searchTree","find","removeNode","tempNode","leftBranch","getMinHeight","rightBranch","getMaxHeight","array","Array","method","toLowerCase","inorder","preorder","postorder","levelorder","result","traverseInOrder","traversePreOrder","traversePostOrder","results","queue","shift","GraphNode","id","adjacents","nodeIds","matrix","vertices","j","nodeId","startId","destinationId","history","source","getNode","destination","visited","_bfs","_dfs","pathExists","stack","pop","neighbor","_quicksort","leftPos","rightPos","log","pivot","_partition","_swap","temp","search","sortedArray","start","end","middle","Math","floor","exists","newSet","myVal"],"mappings":"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","file":"app.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","module.exports = global[\"Library\"] = require(\"-!./global.js\");","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./SimpleDict.ts\");","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Stack.ts\");","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Queue.ts\");","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./index.ts\");","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import { Stack } from \"./ts/datastructures/Stack\";\nimport { Queue } from \"./ts/datastructures/Queue\";\nimport { LinkedList } from \"./ts/datastructures/LinkedList\";\nimport { Set } from \"./ts/datastructures/Set\";\nimport { Map } from \"./ts/datastructures/Map\";\nimport { HashTable } from \"./ts/datastructures/HashTable\";\nimport { BinarySearchTree } from \"./ts/datastructures/Tree\";\nimport { Graph } from \"./ts/datastructures/Graph\";\nimport { SimpleDict } from \"./ts/datastructures/SimpleDict\";\n\nimport { Sorters } from \"./ts/algorithms/Sorters\";\nimport { Searchers } from \"./ts/algorithms/Searchers\";\n\nimport { SubStringSet } from \"./ts/hackerrank/TwoStrings\";\n\n\nmodule.exports =  { Stack, Queue, LinkedList, Set, Map,\n    HashTable, BinarySearchTree, Graph, SimpleDict,\n    Sorters, Searchers, SubStringSet}\n","/**\n * Stack Data Structure\n * @class Stack\n * @author Lee Boonstra\n *\n *      # What do we know about Stacks?\n *      It's a sequential data structure with LIFO. Last In - First Out principle.\n *      (and FILO First in - Last Out)\n *      Compare this to a deck of cards. The last card on top, is the first\n *      card to be removed from the pile. The base card, will be last.\n *\n *      ## Real world examples in Software Engineering?\n *      The browser history. Clipboard history.\n *      In the Sencha Ext JS framework there was a card layout / animation.\n *      The deck of cards in Hearthstone.\n */\nexport class Stack {\n    private items: any[];\n    private total: number;\n\n    constructor() {\n        // Based on an Array\n        this.items = [];\n        // Set the total to 0;\n        this.total = 0;\n    }\n\n    /**\n     * Add a new item to the top of the stack.\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @param {any} item - item\n     */\n    push(item: any) {\n        // this.items.push(item);\n        // We can only add one at a time\n        this.items[this.total] = item;\n        this.total++;\n    }\n\n    /**\n     * Pops / Removes the top item from the stack.\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @return {any} item - removed item\n     */\n    pop(): any {\n        let item = undefined;\n        if (!this.isEmpty()) {\n            this.total--;\n            // return this.items.pop();\n            // manual remove\n            item = this.items[this.total];\n            delete this.items[this.total];\n        }\n        return item;\n    }\n\n    /**\n    * Return the top item from the stack.\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return {item} item - top item\n    */\n    peek(): any {\n        if (this.isEmpty()) return undefined;\n\n        let i = this.total - 1;\n        return this.items[i];\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @returns {boolean} isEmpty - if the Stack is empty or not\n    */\n    isEmpty(): Boolean {\n        return (this.total === 0);\n    }\n\n    /**\n    * Removes all the items from the Stack\n    * Take O(1) time. We do not run any loop in any of these operations.\n    */\n    clear() {\n        if (!this.isEmpty()) {\n            this.items = [];\n            this.total = 0;\n        }\n    }\n\n    /**\n    * Return the total number of items from the stack\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return {number} size - total length of Stack\n    */\n    size(): number {\n        // Note: in this example this.items.length would be wrong\n        // since we are removing values from the array\n        // the array is not shifting.\n        return this.total;\n    }\n\n    /**\n     * Print stack\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @return {array} - array with items\n     */\n    values(): any[] {\n        return this.items;\n    }\n}\n","/**\n * Queue Data Structure\n * @class Queue\n * @author Lee Boonstra\n *\n *      # What do we know about Queues?\n *      It's a sequential data structure with FIFO. First In - First Out principle.\n *      (and LILO Last in - Last Out)\n *      Compare this to the line in at the bakery. First person in the line, takes\n *      a ticket from the counting machine, and will be served first, based on the counter.\n *\n *      ## Real world examples in Software Engineering?\n *      Printer Queue.\n */\nexport class Queue {\n    private items: any[];\n    private total: number; // total items in the queue\n    private count: number; // item count who will be served first\n\n    constructor() {\n        // Based on an Array\n        this.items = [];\n        // A queue needs at least one person.\n        this.total = 1;\n        // Set the count to 0\n        // Compared to Stacks, this is what makes this class different!\n        this.count = 0;\n    }\n\n    /**\n     * Add a new item to the back of the queue.\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @param item any\n     */\n    add(item: any) {\n        this.items[this.items.length] = item;\n        this.total++;\n    }\n\n    /**\n     * Retrieves and removes the head of this queue.\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @return removed item\n     */\n    remove(): any {\n        let item = undefined;\n        if (!this.isEmpty()) {\n            // which item will be first in the queue\n            // is is based on the counting system\n            item = this.items[this.count];\n            // remove this item from the queue\n            delete this.items[this.count];\n            // the queue size is now shorter\n            this.total--;\n            // but the number counter goes up\n            this.count++;\n        }\n        return item;\n    }\n\n    /**\n    * Return the the head of the queue\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return removed item\n    */\n    peek(): any {\n        if (this.isEmpty()) return undefined;\n\n        return this.items[this.count];\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return Boolean\n    */\n    isEmpty(): Boolean {\n        return (this.total <= 1);\n    }\n\n    /**\n    * Removes all the items from the Stack\n    * Take O(1) time. We do not run any loop in any of these operations.\n    */\n    clear() {\n        if (!this.isEmpty()) {\n            this.items = [];\n            this.total = 1;\n            this.count = 0; // reset counter\n        }\n    }\n\n    /**\n    * Return the total number of items from the stack\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return number\n    */\n    size(): number {\n        // Note: in this example this.items.length would be wrong\n        // since we are removing values from the array\n        // the array is not shifting.\n\n        return this.total - 1;\n    }\n\n    /**\n     * Print stack\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @return items\n     */\n    values(): any[] {\n        return this.items;\n    }\n}\n","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./LinkedList.ts\");","/**\n * LinkedList Data Structure\n * @class Node\n * @author Lee Boonstra\n *\n *      # What do we know about LinkedLists?\n *\n *      It's a sequential data structure and has\n *      similarities with an Array (also called a List).\n *      In other languages, an Array has a predefined\n *      size. Inserting and Removing items can be\n *      expensive. Because elements needs to be shifted\n *      over. A LinkedList is a dynamic data structure. We\n *      can add and remove items from it and it will grow\n *      when required. Elements are not placed\n *      contiguously in memory. Each node stores the\n *      element itself and also a reference (pointer\n *      link). Think about this as christmas lights. In\n *      order to find a broken light, you have to visit\n *      each light from beginning (head) to end (tail).\n *\n *      ## Real world examples in Software Engineering?\n *\n *      History and Subversioning? A trial of revisions\n *      and you can add branches?\n */\nexport class Node {\n    public node: Node;\n    public next: Node; // pointer\n    constructor(item: any) {\n        this.node = item;\n        this.next = undefined;\n    }\n}\n\n/**\n * LinkedList Data Structure\n * @class LinkedList\n * @author Lee Boonstra\n *\n *      # What do we know about LinkedLists?\n *\n *      It's a sequential data structure and has\n *      similarities with an Array (also called a List).\n *      In other languages, an Array has a predefined\n *      size. Inserting and Removing items can be\n *      expensive. Because elements needs to be shifted\n *      over. A LinkedList is a dynamic data structure. We\n *      can add and remove items from it and it will grow\n *      when required. Elements are not placed\n *      contiguously in memory. Each node stores the\n *      element itself and also a reference (pointer\n *      link). Think about this as christmas lights. In\n *      order to find a broken light, you have to visit\n *      each light from beginning (head) to end (tail).\n *\n *      ## Real world examples in Software Engineering?\n *\n *      History and Subversioning? A trial of revisions\n *      and you can add branches?\n */\nexport class LinkedList {\n    private head: Node;\n    private total: number;\n\n    constructor() {\n        // when you create a LinkedList the head is empty\n        this.head = null;\n        this.total = 0;\n    }\n\n    /**\n    * Add new item to the end of the LinkedList\n    * Take O(n) time. Loop to figure out the last node.\n    *\n    * @param item: any\n    * @return isAdded Boolean\n    */\n    push(item: any): Boolean {\n        const node = new Node(item);\n        let last_node;\n\n        if (this.getHead() == null) {\n            // the list is empty, adding a new item\n            this.setHead(node);\n        } else {\n            // the list is not empty, append items\n            last_node = this.getHead();\n            // start from the head, keep iterating, till\n            // you find the last node (tail, which is the node with next = null)\n            while (last_node.next != null) {\n                last_node = last_node.next;\n            }\n\n            last_node.next = node;\n        }\n        this.total++;\n\n        return true;\n    }\n\n    /**\n    * Insert a new item at a specified position in the\n    * LinkedList.\n    * Take O(n) time. To find the previous node, we will need to loop.\n    *\n    * @param index: number\n    * @param item: any\n    * @return isInserted Boolean\n    */\n    insert(index: number, item: any): Boolean {\n        let isInserted = false;\n        if (index >= 0 && index <= this.size()) {\n            const newNode = new Node(item);\n\n            if (index === 0) {\n                // This will be the head node.\n                this.setHead(newNode);\n                // update all the references\n            } else {\n                // iterate through all the nodes before the to be added node.\n                // and set a pointer to the next node\n                let previous = this.getNodeAt(index - 1);\n                let current = previous.next;\n                newNode.next = current;\n                previous.next = newNode;\n            }\n\n            // console.log(this.values());\n            this.total++;\n        } else {\n            isInserted = false;\n        }\n\n        return isInserted;\n    }\n\n   /**\n    * Get the very first item in the LinkedList\n    *\n    * @return head: Node\n    */\n    getHead(): Node {\n        return this.head;\n    }\n\n  /**\n    * Set the very first item in the LinkedList\n    *\n    * @param node: Node\n    */\n    setHead(node: Node): void {\n        this.head = node;\n    }\n\n   /**\n    * Get the index of a specific node in the\n    * LinkedList. Returns -1 if it doesn't exist.\n    * Take O(n) time. To find the item, you will need to visit all the nodes\n    *\n    * @param node\n    * @return index: number | -1\n    */\n    indexOf(item: any): number {\n        let index = -1;\n        let node = this.getHead();\n        // keep iterating through the total amount of nodes\n        // till you reach the end (node = null and total)\n        for (let i = 0; i < this.total && node != null; i++) {\n            // this should be the one\n            if (item === node.node) {\n                index = i;\n            }\n            node = node.next;\n        }\n\n        return index;\n    }\n\n    /**\n    * Get the item of a specific index in the\n    * LinkedList. Returns undefined if it doesn't exist.\n    * Take O(n) time. To find the item, you will need to visit all the nodes\n    *\n    * @param index: number\n    * @return node: Node | undefined\n    */\n    getNodeAt(index: number): Node {\n        let node = undefined;\n\n        if (index >= 0 && index <= this.total) {\n            node = this.getHead();\n\n            // keep iterating till you reach the index\n            for (let i = 0; i < index && node != null; i++) {\n                node = node.next;\n            }\n\n        }\n\n        return node;\n    }\n\n    /**\n     * Removes an item from the LinkedList.\n     * Take O(n) time. To find the item to be removed, you will need to visit all the nodes\n     *\n     * @param item: any\n     * @return isRemoved Boolean\n     */\n    remove(item: any): Boolean {\n        let index = this.indexOf(item);\n        let result = this.removeAt(index);\n\n        return result;\n    }\n\n    /**\n     * Removes item from a specified index in the LinkedList.\n     * Take O(n) time. To find the item to be removed, you will need to visit all the nodes.\n     *\n     * @param position: number\n     * @return isRemoved Boolean\n     */\n    removeAt(index: number): Boolean {\n        let isRemoved = false;\n        if (index < 0) {\n            // throw \"Can't remove, because item is not in the LinkedList.\";\n            // console.error(\"Can't remove, because item is not in the LinkedList.\");\n        } else {\n            let current = this.getHead();\n\n            if (index === 0 ) {\n                // this is the very first node\n                // remove (and update all positions)\n                this.setHead(current.next);\n            } else {\n                // iterate through all the nodes before the to be removed node.\n                // and set a pointer to the next node\n                let previous;\n                for (let i = 0; i < index; i++) {\n                    // temp store the one before\n                    previous = current;\n                    // go to the next node\n                    current = current.next;\n                }\n                // now let remove the reference of the previous node\n                // to skip it, and go to the next one.\n                previous.next = current.next;\n            }\n\n            this.total--;\n            isRemoved = true;\n        }\n        return isRemoved;\n    }\n\n    /**\n    * Return the total number of items from the stack\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return number\n    */\n    size() {\n        // Note: in this example this.items.length would be wrong\n        // since we are removing values from the array\n        // the array is not shifting.\n        return this.total;\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    * @returns Boolean\n    */\n    isEmpty() {\n        return (this.total === 0);\n    }\n\n    /**\n    * Helper function to return an array\n    * of the LinkedList values.\n    *\n    * @return arr: Array\n    */\n    values(): any[] {\n        let arr = [];\n        if (this.getHead != null) {\n            let node = this.getHead();\n            for (let i = 0; i < this.size() && node != null; i++) {\n                arr.push(node);\n                // go to next node\n                node = node.next;\n            }\n        }\n        return arr;\n    }\n}\n","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Set.ts\");","/**\n * Set Data Structure\n * @class Set\n * @author Lee Boonstra\n *\n *      # What do we know about Sets?\n *      Set objects are collections of values.\n *      You can iterate through the elements of a set in insertion order.\n *      A value in the Set may only occur once; it is unique in the Set's collection.\n *      Because each value in the Set has to be unique, the value equality will be checked.\n *\n *      Since Set only contains distinct elements, it makes life much easier if we know in advance\n *      we want to avoid saving duplicate data to our structure.\n *      In Mathematics, it has concepts such as union, difference and intersection.\n *\n */\nexport class Set {\n    private items: Object;\n    private total: number;\n\n    constructor() {\n        this.items = {}; // note it's an object, so you can store only one key.\n        this.total = 0;\n    }\n\n    /**\n     * Check if the value exist. If not, add it to the set.\n     *\n     * @param  {string} element - String name value will be used as key and value\n     */\n    add(value: string) {\n        let isCreated = false;\n        if (!this.has(value)) {\n            this.items[this.total] = value;\n            isCreated = true;\n            this.total++;\n        }\n        return isCreated;\n    }\n\n    /**\n     * Remove value from the set\n     *\n     * @param {string} value - String name value will be used as key and value\n     */\n    delete(value: string) {\n        let isRemoved = false;\n        if (this.has(value)) {\n            delete this.items[value];\n            isRemoved = true;\n            this.total--;\n        }\n        return isRemoved;\n    }\n\n    /**\n     * Check if the value exist.\n     * Returns a boolean asserting whether an element is present with the given value in the Set object or not.\n     *\n     * @param {string} value - the value\n     * @return {boolean} isExisting - Boolean, returns true if value exists in Set.\n     */\n    has(value: string): Boolean {\n        let isExisting = false;\n        for (let key in this.items) {\n\n            if (this.items.hasOwnProperty(key)) {\n                 if (this.items[key] === value ) {\n                     if (parseInt(key) <= this.size()) {\n                        isExisting = true;\n                     }\n                 }\n            }\n        }\n        return isExisting;\n    }\n\n    /**\n     * Returns an array with all the keys of the Set\n     *\n     * @return {array} keys - Array with all the keys of the set\n     */\n    keys() {\n        let arr = [];\n        for (let item in this.items) {\n            arr.push(item)\n        }\n\n        return arr;\n    }\n\n    /**\n     * Returns an array with all the values of the Set\n     *\n     * @return {array} values - Array with all the values of the set\n     */\n    values() {\n        let arr = [];\n        for (let item in this.items) {\n            arr.push(this.items[item]);\n        }\n\n        return arr;\n    }\n\n    /**\n    * Removes all elements from the Set object.\n    */\n    clear(): void {\n        this.items = {};\n        this.total = 0;\n    }\n\n    /**\n    * Returns the number of values in the Set object.\n    *\n    * @return {number} total - Total amount of items in Set\n    */\n    size(): number {\n        return this.total;\n    }\n\n   /**\n    * Executes the callback function, for each item in the Set.\n    *\n    * @param {function} callback(key, val, set) - Callback function with 3 args key, value and set.\n    */\n    forEach(callback: Function) {\n        for (let key in this.items) {\n            callback(key, this.items[key], this.items);\n        }\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @returns {boolean} isEmpty - if the Stack is empty or not\n    */\n    isEmpty(): Boolean {\n        return (this.total === 0);\n    }\n\n    /**\n     * Given two sets, this returns a new set of elements from both of the given sets.\n     *\n     * @param {Set} otherSet - Another Set\n     * @return {Set} unionSet - Return a combined set.\n     */\n    union(otherSet: Set) {\n        let unionSet = new Set();\n\n        this.forEach(function(key: number, val: string, set: Set) {\n            unionSet.add(val)\n        });\n        otherSet.forEach(function(key: number, val: string, set: Set) {\n            unionSet.add(val)\n        });\n\n        return unionSet;\n    }\n\n    /**\n     * Given two sets, this returns a new set from elements that exist in both sets.\n     *\n     * @param {Set} otherSet - Another Set\n     * @return {Set} intersection - Return a intersection set.\n     */\n    intersection(otherSet: Set) {\n        let intersection = new Set();\n\n        this.forEach(function(key: number, val: string, set: Set) {\n            if (otherSet.has(val)) {\n                intersection.add(val);\n            }\n        });\n        return intersection;\n    }\n\n    /**\n     * Given two sets, this returns a new set with all the elements that\n     * exist in your set but not in the other set.\n     *\n     * @param {Set} otherSet - Another Set\n     * @return {Set} difference - Return a difference set.\n     */\n    difference(otherSet: Set) {\n        let difference = new Set();\n\n        this.forEach(function(key: number, val: string, set: Set) {\n            if (!otherSet.has(val)) {\n                difference.add(val);\n            }\n        });\n\n        return difference;\n    }\n\n    /**\n     * Given two sets, confirm with a boolean if this is a subset of another set.\n     *\n     * @param {Set} otherSet - Another Set\n     * @return {boolean} isSubset - Return boolean true if this is a subset.\n     */\n    isSubset(otherSet: Set) {\n        let isSubset = false;\n        let counter = 0;\n\n        // if this set is bigger than the other set, it can't be a subset\n        if (this.size() <= otherSet.size()) {\n            // loop through all items, and check if my values\n            // also exist in the other set.\n            // all values will need to exist.\n            this.forEach(function(key: number, val: string, set: Set) {\n                if (otherSet.has(val)) {\n                    counter++;\n                }\n            });\n        }\n\n        if (counter === this.size()) {\n            isSubset = true;\n        }\n\n        return isSubset;\n    }\n}\n","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Map.ts\");","/**\n * Map Data Structure\n * @class Map\n * @author Lee Boonstra\n *\n *      # What do we know about Map?\n *      Set objects are collections of key value pairs\n *      The key can be used to find a particular element.\n *      Other names are Dictionary, Symbol table or Associative Arrays\n *\n *      In computer science, maps are often used to store the refefence address of an object.\n *      For example, look in your Developer Tools, Memory tab and look at the Snapshots\n */\nexport class Map {\n    private items: Object;\n    private total: number;\n\n    constructor() {\n        this.items = {}; // note it's an object, so you can store only one key.\n        this.total = 0;\n    }\n\n    /**\n     * Check if the key exist. If not, add a key value pair\n     *\n     * @param  {string} key - String name key will be used as key and value\n     * @param  {string} value - String name value will be used as key and value\n     */\n    set(key: string, value: string) {\n        let isCreated = false;\n        if (!this.hasKey(key.toString())) {\n            this.items[key] = value;\n            isCreated = true;\n            this.total++;\n        }\n        return isCreated;\n    }\n\n    /**\n     * Remove value from the set\n     *\n     * @param  {string} key - String name key will be used as key and value\n     */\n    remove(key: string) {\n        let isRemoved = false;\n        if (this.hasKey(key.toString())) {\n            delete this.items[key];\n            isRemoved = true;\n            this.total--;\n        }\n        return isRemoved;\n    }\n\n    /**\n     * Check if the key exist.\n     * Returns a boolean asserting whether a key is present in the Map.\n     *\n     * @param {string} key - the key\n     * @return {boolean} isExisting - Boolean, returns true if value exists in Map.\n     */\n    hasKey(key: string): Boolean {\n        let isExisting = false;\n        if (this.items[key]) {\n            isExisting = true;\n        }\n        return isExisting;\n    }\n\n    /**\n     * Get the value from a specific key\n     *\n     * @param {string} key - the key\n     * @return {string} value - the value from the key\n     */\n    get(key: string): String {\n        return this.items[key.toString()];\n    }\n\n    /**\n     * Returns an array with all the keys of the Set\n     *\n     * @return {array} keys - Array with all the keys of the set\n     */\n    keys() {\n        let arr = [];\n        for (let item in this.items) {\n            arr.push(item)\n        }\n\n        return arr;\n    }\n\n    /**\n     * Returns an array with all the values of the Set\n     *\n     * @return {array} values - Array with all the values of the set\n     */\n    values() {\n        let arr = [];\n        for (let item in this.items) {\n            arr.push(this.items[item]);\n        }\n\n        return arr;\n    }\n\n    /**\n    * Removes all elements from the Set object.\n    */\n    clear(): void {\n        this.items = {};\n        this.total = 0;\n    }\n\n    /**\n    * Returns the number of values in the Set object.\n    *\n    * @return {number} total - Total amount of items in Set\n    */\n    size(): number {\n        return this.total;\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @returns {boolean} isEmpty - if the Stack is empty or not\n    */\n    isEmpty(): Boolean {\n        return (this.total === 0);\n    }\n\n\n   /**\n    * Executes the callback function, for each item in the Set.\n    *\n    * @param {function} callback(key, val, set) - Callback function with 3 args key, value and set.\n    */\n    forEach(callback: Function) {\n        for (let key in this.items) {\n            callback(key, this.items[key], this.items);\n        }\n    }\n}\n","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./HashTable.ts\");","import { SimpleDict } from './SimpleDict';\n\n/**\n * HashTable Data Structure\n * @class HashTable\n * @author Lee Boonstra\n *\n *      # What do we know about HashMap?\n *      Very similar to Maps/Associative Arrays, for storing\n *      key value pairs. You can find a stored value in the shortest\n *      time possible, O(1), rather than looping though each\n *      array value O(n) or using a sorted binary array\n *      or Tree O(log n).\n *\n *      Think about a student is assigned a student number\n *      that can be used to find information about him.\n *\n *      To make sure all key values in a HashTable are short\n *      as possible, and are integers to do fast lookup,\n *      we will need a hashing function.\n *      You will need to find a good hashing function, one\n *      that doesn't take too long to create a hash (when inserting/\n *      getting or removing). But you also don't want to make it\n *      to simple so you create collisions.\n *\n *      Although hash tables provide fast insertion, deletion, and retrieval,\n *      they perform poorly for operations that involve searching, such as finding the\n *      minimum and maximum values in a data set. For these operations, other data structures\n *      such as the binary search tree are more appropriate. Access and Deletion in worst case O(n)\n *\n *      ## Real world examples in Software Engineering?\n *      Browser vendors use hashtables a lot.\n *      But also when you use a database, you would set indexes to allow faster searching\n *\n */\nexport class HashTable {\n    private table: any[];\n    private total: number;\n    public bucketSize: number;\n    private probe: boolean;\n    private uniqueKeys: boolean;\n\n    /**\n     * @param {Object} opt - (optional)\n     * @param {boolean} opt.probe - enable probing default false\n     * @param {number} opt.bucketSize - if bucketSize set, create max HashTable buckets total. Less buckets is higher chance on collisions. Default 0, use good hashing function.\n     * @param {boolean} opt.uniqueKeys - skip duplicate key names so keys are unique default true\n     */\n    constructor(opt: any) {\n        this.table = [];\n        this.total = 0;\n        this.bucketSize = (opt.bucketSize || 0);\n        this.probe = (opt.probe || false);\n        this.uniqueKeys = (opt.uniqueKeys || true)\n    }\n\n    /**\n     * Check if the key exist. If not, add a key value pair\n     *\n     * @param  {string} key - String name key will be used as key and value\n     * @param  {string} value - String name value will be used as key and value\n     */\n    put(key: string, value: string) {\n        let isCreated = false;\n        let hash = this.hashCode(key);\n        if (!this.hasHash(hash)) {\n            this.table[hash] = new SimpleDict();\n            this.table[hash].set(key, value);\n            isCreated = true;\n            this.total++;\n        } else {\n            if (this.probe) {\n                let index = hash + 1;\n                while (this.table[index] !== undefined) {\n                    index++;\n                }\n                this.table[index] = new SimpleDict();\n                this.table[index].set(key, value);\n                isCreated = true;\n                this.total++;\n            } else {\n                // the hash already exists\n                if (this.uniqueKeys && this.table[hash].keys[0] === key) {\n                    // but the key is not unique\n                    // please skip duplicate\n                    console.error(key + ' already exists in HashTable, so skipped.');\n                } else {\n                    // now I want not a SimpleDict but an Array\n                    if (this.table[hash].constructor === SimpleDict) {\n                        let current = this.table[hash];\n                        this.table[hash] = []; // TODO or a LinkedList\n                        this.table[hash].push(current);\n                    }\n                    // its an array, add the new item\n                    let newItem = new SimpleDict();\n                    newItem.set(key, value);\n                    this.table[hash].push(newItem);\n                    isCreated = true;\n                    this.total++;\n                }\n            }\n        }\n\n        return isCreated;\n    }\n\n\n\n    /**\n     * Remove key value pair from the HashMap. When Collision with LinkedList is enabled, it will remove all occurences.\n     * When not probing best case O(1) worst case O(n).\n     *\n     * @param  {string} key - String name key will be used as key and value\n     */\n    remove(key: string) {\n        let isRemoved = false;\n        let hash = this.hashCode(key);\n        // when probing is enabled, and the table size doesn't match\n        // the bucket size, we will need to probe again to find\n        // the key back.\n        if (this.probe && (this.table.length !== this.bucketSize)) {\n            let index = hash;\n            // keep looping through you find the key\n            while (this.table[index].keys[0] !== key) {\n                index++;\n            }\n            this.table[index].remove(key);\n            isRemoved = true;\n            this.total--;\n        } else {\n            this.table[hash].remove(key);\n            isRemoved = true;\n            this.total--;\n        }\n\n        return isRemoved;\n    }\n\n    /**\n     * Check if the hash exist.\n     * Returns a boolean asserting whether a key is present in the Map.\n     *\n     * @param {number} hash - the hash\n     * @return {boolean} isExisting - Boolean, returns true if value exists in Map.\n     */\n    hasHash(hash: number): boolean {\n        let isExisting = false;\n        if (this.table[hash]) {\n            isExisting = true;\n        }\n        return isExisting;\n    }\n\n    /**\n     * Get the KeyValue Object pair from a specific key\n     * When not probing best case O(1) worst case O(n)\n     *\n     * @param {string} key - the key\n     * @return {Object | Array } return KeyValue Object or incase of LinkedList collision, an array with multiples.\n     */\n    get(key: string) {\n        let hash = this.hashCode(key);\n        let itemValue = undefined;\n\n        // when probing is enabled, and the table size doesn't match\n        // the bucket size, we will need to probe again to find\n        // the key back.\n        if (this.probe && (this.table.length !== this.bucketSize)) {\n            let index = hash;\n            // keep looping through you find the key\n            while (this.table[index].keys[0] !== key) {\n                index++;\n            }\n            itemValue = this.table[index].get(key);\n        } else {\n            if (this.table[hash].constructor === SimpleDict) {\n                itemValue = this.table[hash].get(key);\n            } else {\n                // there are multiples with this hash\n                // so we have to loop\n                let i = 0;\n                while (key !== this.table[hash][i].keys[0]) {\n                    i++;\n                }\n                itemValue = this.table[hash][i].get(key);\n            }\n        }\n\n        return itemValue;\n    }\n\n    /**\n    * Removes all elements from the Set object.\n    */\n    clear(): void {\n        this.table = [];\n        this.total = 0;\n    }\n\n    /**\n    * Returns the number of values in the Set object.\n    *\n    * @return {number} total - Total amount of items in Set\n    */\n    size(): number {\n        return this.total;\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @returns {boolean} isEmpty - if the Stack is empty or not\n    */\n    isEmpty(): Boolean {\n        return (this.total === 0);\n    }\n\n   /**\n    * Executes the callback function, for each item in the Set.\n    *\n    * @param {function} callback(key, val, set) - Callback function with 3 args key, value and set.\n    */\n    forEach(callback: Function) {\n        for (let key in this.table) {\n            callback(key, this.table[key], this.table);\n        }\n    }\n\n    /**\n     * Create a hash based on a key string\n     * The Hash-function takes a key and converts it to a number which will be the index at which to store it.\n     * I am computing a hash value by summing the ASCII value of each character of the string\n     * , multiplying the ASCII value by a multiplier 'code', which in this case, is an odd prime 37.\n     * And the reason to choose 37 being, by some empirical research, if we take over 50,000 English words\n     * will produce less than 7 collisions in each case, while creating a hasing function.\n     *\n     * @param {string} key - the key\n     */\n    hashCode(key: string): number {\n        let hash = 0;\n        const code = 37;\n        for (let i = 0; i < key.length; i++) {\n          hash += code * hash + key.charCodeAt(i);\n        }\n        if (this.bucketSize !== 0) {\n            hash = hash % this.bucketSize;\n        }\n        return hash;\n    }\n}\n","/**\n * Simple Associative Array / Dictionary\n * @class SimpleDict\n * @author: Lee Boonstra\n *\n * A simple Associative Array / Matrix\n * Slow O(n)\n*/\nexport class SimpleDict {\n    private keys: any[];\n    private values: any[];\n    private total: number;\n\n    constructor() {\n        this.keys = [];\n        this.values = [];\n        this.total = 0;\n    }\n\n    /**\n    * Set key value pair in SimpleDict\n    * O(1)\n    * @param {string} key - the key value\n    * @param {any} value - the value\n    * @returns {Boolean} true if succesful created\n    */\n    set(key: string, value: any): Boolean {\n        this.keys.push(key);\n        this.values.push(value);\n        this.total++;\n\n        return true;\n    }\n\n    /**\n    * Remove key value pair in SimpleDict\n    * O(n)\n    * @param {string} key - the key value\n    * @returns {Boolean} true if succesful removed\n    */\n    remove(key: string): Boolean {\n        let isRemoved = false;\n        for (let i = 0; i < this.keys.length; i++) {\n            if (this.keys[i] === key) {\n                delete this.keys[i];\n                delete this.values[i];\n                this.total--;\n                isRemoved = true;\n            }\n        }\n        return isRemoved;\n    }\n\n    /**\n    * Get value from SimpleDict\n    * O(n)\n    * @param {string} key - the key value\n    * @returns {any} value - the value that belongs to the key\n    */\n    get(key: string): any {\n        for (let i = 0; i < this.keys.length; i++) {\n            if (this.keys[i] === key) {\n                return this.values[i];\n            }\n        }\n    }\n\n   /**\n     * Check if the key exist.\n     * Returns a boolean asserting whether a key is present in the Map.\n     *\n     * @param {string} key - the key\n     * @return {boolean} isExisting - Boolean, returns true if value exists in Map.\n     */\n    hasKey(key: string): Boolean {\n        return (this.get(key) ? true : false);\n    }\n\n    /**\n    * Get total size from SimpleDict\n    * O(1)\n    * @returns {number} total - the size of the SimpleDict\n    */\n    size(): number {\n        return this.total;\n    }\n\n    /**\n    * Checks if SimpleDict is empty\n    * O(1)\n    * @returns {boolean} isEmpty\n    */\n    isEmpty(): boolean {\n        return this.total === 0;\n    }\n\n    /**\n    * Clear the SimpleDict\n    * O(1)\n    * @returns {number} total - the size of the SimpleDict\n    */\n    clear(): number {\n        this.keys = [];\n        this.values = [];\n        this.total = 0;\n        return this.total;\n    }\n}","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Tree.ts\");","/**\n * TreeNode DataStructure\n * @class TreeNode\n * @author Lee Boonstra\n *\n */\nexport class TreeNode {\n    public key: number;\n    public left: TreeNode;\n    public right: TreeNode;\n\n    constructor(key: number, left: TreeNode = null, right: TreeNode = null) {\n        this.key = key;\n        this.left = left;\n        this.right = right\n    }\n}\n\n/**\n * Tree DataStructure\n * @class Tree\n * @author Lee Boonstra\n *\n *      # What do we know about Trees?\n *      A Tree is a non-linear data structure where data objects\n *      are organized in terms of hierarchical relationship.\n *      The structure is non-linear in the sense that,\n *      unlike simple array and linked list implementation,\n *      data in a tree is not organized linearly. Each data\n *      element is stored in a structure called a node.\n *\n *      Think about an organization chart of family tree.\n *\n *      ## BinarySearchTree (BST)\n *      A Node in a Tree can have multiple branches. In a BST\n *      the BST Node can only have 2 branches. One on the left,\n *      and one on the right. They are ordered. The left branch\n *      have values that are <= (lower or equal) than the parent node.\n *      The right branch has values that are => than the parent node.\n *      Therefore each lookup, insertion or deletion takes time\n *      in proporsional to the logarithm (log) of the number of the\n *      total items in the tree. (You can skip half of the tree).\n *      O(log n) instead of O(n) when sorting an array. However it is\n *      slower than the operations than a hashtable O(1).\n *\n *      ## Depth First Search (DFS)\n *\n *      ## Breadth First Search (BFS)\n *\n *      ## Real world examples in Software Engineering?\n *      DOM (Document Object Model)\n */\nexport class BinarySearchTree {\n    private root: TreeNode;\n\n    constructor() {\n        this.root = null;\n    }\n\n    // findMinNode()\n    // search(node, data)\n\n    /**\n     * Get the Root Node Value\n     * @returns {number | null} The Root Node Value\n     */\n    getRootNodeValue(): any {\n        let key = null;\n        if (this.root !== null) {\n            key = this.root.key;\n        }\n        return key;\n    }\n\n    /**\n     * Insert a node to a tree\n     * @param {number} key\n     */\n    insert(key: number) {\n        const node = this.root;\n        if (node == null) {\n            // this is the root node\n            // create a node based on this key\n            this.root = new TreeNode(key)\n            return;\n        } else {\n            // it's not the root node,\n            // so we will need to figure\n            // where to place this in the tree.\n            // let's use a recursive funciton\n            const searchTree = function(node: TreeNode): void {\n                // the key is smaller the parent node\n                if (key < node.key) {\n                    // when there are no nodes on the left side\n                    // we can start creating a node\n                    if (node.left == null) {\n                        // put it on the left side of the tree\n                        node.left = new TreeNode(key);\n                        return;\n                    } else if (node.left !== null) {\n                        // there are already nodes on the left\n                        // so we use a recursive function\n                        // passing in the node.left we just saw\n                        searchTree(node.left)\n                    }\n                } else if (key > node.key) {\n                    // when there are no nodes on the right side\n                    // we can start creating a node\n                    if (node.right == null) {\n                        // put it on the right side of the tree\n                        node.right = new TreeNode(key);\n                        return;\n                    } else if (node.right !== null) {\n                        // there are already nodes on the right\n                        // so we use a recursive function\n                        // passing in the node.right we just saw\n                        searchTree(node.right)\n                    } else {\n                        // the key must be equal. we won't add\n                        // it to the tree, we skip duplicates\n                        return null;\n                    }\n                }\n            }\n            // we will call the function\n            return searchTree(node);\n        }\n    }\n\n    /**\n     * This method returns the minimum value/key in the tree\n     */\n    min(): number {\n        let current = this.root;\n        // a while loop, continue searching\n        // till you are on the end of the left branch\n        while (current.left !== null && current.left !== undefined) {\n            current = current.left;\n        }\n        return current.key;\n    }\n\n    /**\n     * This method returns the maximum value/key in the tree\n     */\n    max(): number {\n        let current = this.root;\n        // a while loop, continue searching\n        // till you are on the end of the left branch\n        while (current.right != null) {\n            current = current.right;\n        }\n        return current.key;\n    }\n\n    /**\n     * This method searches for the key in the tree. It\n     * returns true if it exist and false if the node\n     * does not exist.\n     * @param {number} key - Key to search for\n     */\n    contains(key: number): boolean {\n        return (this.find(key) !== null)\n    }\n\n    /**\n     * This method searches for the key in the tree. It\n     * returns the TreeNode.\n     * @param {number} key - Key to search for\n     * @returns {TreeNode} - return node\n     */\n    find(key: number): TreeNode {\n        let current = this.root;\n        // when the current node is not null\n        while (current) {\n            // is it the current key?\n            if (key === current.key) {\n                // yep, found it\n                return current;\n            } else if (key < current.key) {\n                // value is lower than the parent\n                // let's look left\n                current = current.left;\n            } else {\n                // value is higher than the parent\n                // let's look right\n                current = current.right;\n            }\n            // haven't found it so continue looking\n        }\n        // we didn't find it, the key might be not in the tree\n        return null;\n    }\n\n    /**\n     * Removes a node in a tree.\n     * @param {number} data\n     */\n    remove(key: number) {\n        const removeNode = function(node: TreeNode, key: number): TreeNode {\n            if (node == null) {\n                // we have an empty tree\n                return null;\n            }\n            // can we find the data in the tree\n            if (key === node.key) {\n                // when the value is in the tree,\n                // there are 4 options:\n\n                // 1)\n                // node has no children, means its a leaf node\n                // we can just delete that node by setting\n                // the data of that node to null. (removing pointers)\n                if (node.left === null && node.right === null) {\n                    return null;\n                }\n\n                // 2)\n                // node has no left child\n                // we will replace pointers\n                // the parent node will get\n                // the right node from the to be deleted node\n                // as a new pointer\n                if (node.left === null) {\n                    return node.right;\n                }\n\n                // 3)\n                // node has no right child\n                // we will replace pointers\n                // the parent node will get\n                // the left node from the to be deleted node\n                // as a new pointer\n                if (node.right === null) {\n                    return node.left;\n                }\n\n                // 4)\n                // node has both children\n                // this is a bit more complicated\n                // cause you can't replace pointers\n                // of one, cause what would happen to the\n                // other child.\n\n                // we will first look to the right node\n                let tempNode = node.right;\n                // and find the min in the branch by\n                // looking all the way left\n                while (tempNode.left !== null) {\n                    tempNode = tempNode.left;\n                };\n                // the node that will need to be deleted\n                // gets the node data from the tempNode\n                // the one from all the way left\n                node.key = tempNode.key;\n\n                // and we will need to go back in this function\n                // again to make sure we re-link all the other\n                // pointers\n                node.right = removeNode(node.right, tempNode.key);\n                return node;\n            } else if (key < node.key) {\n                node.left = removeNode(node.left, key);\n                return node;\n            } else {\n                node.right = removeNode(node.right, key);\n                return node;\n            }\n        }\n        // call the recursive function, start with the root\n        this.root = removeNode(this.root, key);\n    }\n\n\n    /**\n     * Get the Tree Min Height\n     * Recursive Function\n     * @param {TreeNode} node - (default) rootNode\n     * @returns {number} minHeight - of the tree\n     */\n    getMinHeight(node = this.root): number {\n        if (node == null) {\n            // every time when you reach the leaf node\n            // return -1, so it's a number;\n            return -1;\n        }\n\n        // when node is not null, so it's not a leaf\n        // call this function again, passing in the\n        // previous node, that way you are walking\n        // through all the lefts, and all the rights.\n        let leftBranch = this.getMinHeight(node.left);\n        let rightBranch = this.getMinHeight(node.right);\n\n        // when the left branche is smaller\n        // start walking left, otherwise\n        // walk through the right branche\n        // and start counting (+1) till the end (null)\n\n        // the branch that's the smallest\n        // will contain the min height\n        if (leftBranch < rightBranch) {\n            return leftBranch + 1;\n        } else {\n            return rightBranch + 1;\n        }\n    }\n\n    /**\n     * Get the Tree Max Height\n     * @param {TreeNode} node - (default) rootNode\n     * @returns {number} maxHeight - of the tree\n     */\n    getMaxHeight(node = this.root): number {\n        if (node == null) {\n            // every time when you reach the leaf node\n            // return -1, so it's a number;\n            return -1;\n        }\n\n        // when node is not null, so it's not a leaf\n        // call this function again, passing in the\n        // previous node, that way you are walking\n        // through all the lefts, and all the rights.\n        let leftBranch = this.getMaxHeight(node.left);\n        let rightBranch = this.getMaxHeight(node.right);\n\n        // when the left branche is bigger\n        // start walking left, otherwise\n        // walk through the right branche\n        // and start counting (+1) till the end (null)\n\n        // the branch that's the biggest\n        // will contain the max height\n        if (leftBranch > rightBranch) {\n            return leftBranch + 1;\n        } else {\n            return rightBranch + 1;\n        }\n    }\n\n    /**\n     * Is Tree Balanced? A tree is balanced when the branches are equal or have 1 level difference.\n     * @returns {boolean} if the Tree is Balanced\n     */\n    isBalanced(): boolean {\n        return(this.getMinHeight()\n            >= this.getMaxHeight() - 1);\n    }\n\n    /**\n     * Traverse the tree\n     * @param {object} opt\n     * @param {string} opt.method - inOrder | preOrder | postOrder | levelOrder (default inOrder); \n     * @returns {array} - sorted array\n     */\n    traverse(opt: any): any {\n        let array = new Array();\n        let method = \"\";\n        if (opt.method) {\n            method = opt.method.toLowerCase();\n        }\n        // console.log(method);\n        switch (method) {\n            case \"inorder\":\n                array = this.inorder();\n                break;\n            case \"preorder\":\n                array = this.preorder();\n                break;\n            case \"postorder\":\n                array = this.postorder();\n                break;\n            case \"levelorder\":\n                array = this.levelorder();\n                break;\n            default:\n                array = this.inorder();\n        }\n\n        return array;\n    }\n\n    /**\n     * Traverses nodes of a tree with DFS\n     * @returns {array} - return an inorder array\n     */\n    inorder(): any[] {\n        if (this.root == null) {\n            // check if there's a BST\n            // and if there are values\n            // in it\n            // console.log(\"root = null\");\n            return null;\n        } else {\n            let result = new Array();\n            // recursive function\n            function traverseInOrder(node: TreeNode) {\n                // we start from the root node.\n\n                // if the current node has a node.left\n                // then call this function\n                // again but pass in the left node\n                // else ignore\n                // if (node.left) console.log(\"execute if node \" + node.key + \" has a left: \" + node.left.key);\n                node.left && traverseInOrder(node.left);\n\n                // and then add the value to the array\n                // so for everytime you called the \n                // function, you still will add values\n                // to the array\n                // console.log(\"push in array \" + node.key);\n                result.push(node.key);\n\n                // next, check if the current node has\n                // a right node. else ignore\n                // in case not, go up\n                // pass that node to the array\n\n                // if node.right does exist call this function\n                // again but pass in the right node\n                // if (node.right) console.log(\"execute if node \" + node.key + \" has a right: \" + node.right.key);\n                node.right && traverseInOrder(node.right);\n            }\n            traverseInOrder(this.root);\n            return result;\n        }\n    }\n\n    /**\n     * Traverses nodes of a tree with BFS\n     * @returns {array} - return an preorder array\n     */\n    preorder(): any[] {\n        if (this.root == null) {\n            // check if there's a BST\n            // and if there are values\n            // in it\n            return null;\n        } else {\n            let result = new Array();\n            // recursive function\n            function traversePreOrder(node: TreeNode) {\n                // add the key in the results array\n                result.push(node.key);\n                // if node.left exist call this function\n                // again but pass in the left node\n                node.left && traversePreOrder(node.left);\n                // if node.right exist call this function\n                // again but pass in the right node\n                node.right && traversePreOrder(node.right);\n            }\n            traversePreOrder(this.root);\n            return result;\n        }\n    }\n\n    /**\n     * Traverses nodes of a tree with BFS\n     * @returns {array} - return an postorder array\n     */\n    postorder(): any[] {\n        if (this.root == null) {\n            // check if there's a BST\n            // and if there are values\n            // in it\n            return null;\n        } else {\n            let result = new Array();\n            // recursive function\n            function traversePostOrder(node: TreeNode) {\n                // if node.left exist call this function\n                // again but pass in the left node\n                node.left && traversePostOrder(node.left);\n                // if node.right exist call this function\n                // again but pass in the right node\n                node.right && traversePostOrder(node.right);\n                // add the key in the results array\n                result.push(node.key);\n            }\n            traversePostOrder(this.root);\n            return result;\n        }\n    }\n\n    /**\n     * Traverses nodes for each level\n     * @returns {array} - return an level order array\n     */\n    levelorder(): any {\n        let results = [];\n        let queue = [];\n        if (this.root != null) {\n            queue.push(this.root);\n            // now we will loop\n            // as long as there are\n            // items in the queue\n            while (queue.length > 0) {\n                let node = queue.shift();\n                // takes the first element in the\n                // array and remove that element\n                // so we will start with the rootnode\n                // in the queue. and after shifting\n                // it's not in the queue anymore\n\n                // we can put the key in the results array\n                results.push(node.key);\n\n                if (node.left != null) {\n                    // console.log(node.key + \" has a left node: \" + node.left.key)\n                    // when there is a left node\n                    // we can put it to the queue\n                    // so the while loop won't stop\n                    queue.push(node.left);\n                }\n                if (node.right != null) {\n                    // console.log(node.key + \" has a right node: \" + node.right.key)\n\n                    // when there is a right node\n                    // we can put it to the queue\n                    // so the while loop won't stop\n                    queue.push(node.right);\n                }\n\n                // when there are items in the queue,\n                // we can start adding it to the results\n                // array, and start checking for the next\n                // level.\n            }\n            return results;\n        } else {\n            return null;\n        }\n    }\n}","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Graph.ts\");","import { Queue } from '../datastructures/Queue';\nimport { Stack } from '../datastructures/Stack';\nimport { SimpleDict } from '../datastructures/SimpleDict';\n\n/**\n * Each node object  / Vertex\n * @class GraphNode\n * @author Lee Boonstra\n * @param {string} id - string with the node id\n */\nexport class GraphNode {\n    public id: string;\n    public adjacents: Array<string>;\n\n    constructor(id: string) {\n        this.id = id;\n        this.adjacents = new Array();\n    }\n}\n\n/**\n * Create a Graph\n * @class Graph\n * @author Lee Boonstra\n * @param {array} nodeIds - An array with all the string ids to be created\n * @param {array} matrix - A 2 dimensional array (matrix), used as an adjacency list\n */\nexport class Graph {\n    private vertices: Object;\n    private nodeIds: any[];\n    public matrix: any[];\n\n    constructor (nodeIds: Array<string>, matrix: any) {\n        this.matrix = matrix;\n        this.nodeIds = nodeIds;\n        this.vertices = {};\n\n        // the matrix should have for each row a vertex\n        if (nodeIds.length !== this.matrix.length) {\n            throw \"The size of the matrix doesn't contain the total of vertices\";\n        }\n\n        // loop through the array rows\n        for (let i = 0; i < matrix.length; i++) {\n            // create a vertex node, for each row in the matrix\n            let node = new GraphNode(this.nodeIds[i]);\n\n            // loop through all the adjacents\n            for (let j = 0; j < this.matrix[i].length; j++) {\n                // Add the adjacent, when it's marked\n                // as one in the matrix.\n                if (matrix[i][j] === 1) {\n                    node.adjacents.push(this.nodeIds[j]);\n                }\n            }\n\n            // each vertex gets a row in the vertices array\n            this.vertices[node.id] = node;\n        }\n\n        // console.log(this.vertices);\n    }\n\n\n\n    /**\n     * Get the Node that belongs to a particular node id.\n     * @param {number} nodeId - Node id to look for\n     * @returns {Node} node - The matching node\n     */\n    getNode(nodeId: string): GraphNode {\n        return this.vertices[nodeId];\n    }\n\n    addNode() {\n\n\n\n\n    }\n\n    addEdge() {\n\n    }\n\n   /**\n     * Log Breadth First Path from one node to another\n     * Go wide, and first check all neighbor nodes. (adjacents) before going deep.\n     * @param {string} startId - The Node Id to start searching from\n     * @param {string} destinationId - The Node Id that needs to be found\n     * @returns {array} history - return a DFS array\n     */\n    public getBfsPath(startId: string, destinationId: string): Array<string> {\n        let history = [];\n        let source = this.getNode(startId);\n        let destination = this.getNode(destinationId);\n        let visited = new SimpleDict();\n\n        history = this._bfs(source, destination, visited);\n        if (history === false) {\n            history = [];\n        }\n        return history;\n    }\n\n    /**\n     * Log Depth First Path from one node to another\n     * Go deep into nodes, before exploring other nodes.\n     * @param {string} startId - The Node Id to start searching from\n     * @param {string} destinationId = The Node Id that needs to be found\n     * @returns {array} history - return a DFS array\n     */\n    public getDfsPath (startId: string, destinationId: string): Array<string> {\n        let history = [];\n        let source = this.getNode(startId);\n        let destination = this.getNode(destinationId);\n        let visited = new SimpleDict();\n\n        history = this._dfs(source, destination, visited);\n        if (history === false) {\n            history = [];\n        }\n        return history;\n    }\n\n    /**\n     * Check if Path exist via Depth First Search\n     * Go deep into nodes, before exploring other nodes.\n     * Using a Stack\n     * @param {string} startId - The Node Id to start searching from\n     * @param {string} destinationId - The Node Id that needs to be found\n     * @returns {boolean} pathExists - return true if a path was found\n     */\n    public hasPathDfs(startId: string, destinationId: string): boolean {\n        let pathExists = false;\n        let source = this.getNode(startId);\n        let destination = this.getNode(destinationId);\n        let visited = new SimpleDict();\n\n        pathExists = this._dfs(source, destination, visited);\n        return (pathExists !== false);\n    }\n\n    /**\n     * Check if Path exist via Breath First Search\n     * Go wide, and first check all neighbor nodes. (adjacents) before going deep.\n     * Using a Queue\n     * @param {string} startId - The Node Id to start searching from\n     * @param {string} destinationId - The Node Id that needs to be found\n     * @returns {boolean} pathExists - return true if a path was found\n     */\n    public hasPathBfs(startId: string, destinationId: string): boolean {\n        let pathExists = false;\n        let source = this.getNode(startId);\n        let destination = this.getNode(destinationId);\n        let visited = new SimpleDict();\n\n        pathExists = this._bfs(source, destination, visited);\n\n        return (pathExists !== false);\n    }\n\n\n   /**\n     * Check if Path exist via Depth First Search\n     * Go deep into nodes, before exploring other nodes.\n     * Using Stacks\n     * @param {GraphNode} source - The Node to start searching from\n     * @param {GraphNode} destination - The Node that needs to be found\n     * @param {SimpleDict} visited - A Simple Dictionary holding the references to the visisted vertices\n     * @returns {boolean} pathExists - return true if a path was found\n     */\n    private _dfs(source: GraphNode, destination: GraphNode, visited: SimpleDict): any {\n        let stack = new Stack();\n        let history = [];\n        stack.push(source);\n\n        while (!stack.isEmpty()) {\n            // as long as there are items in the queue\n            // keep running this\n\n            // get the item from the queue\n            let node = stack.pop();\n\n            // console.log(node.id);\n\n            // the node you are looking for\n            // is the same as the destination\n            if (node === destination) {\n                history.push(node.id);\n                // path of all visited\n                return history;\n            }\n\n            if (visited.hasKey(node.id)) {\n                // you have visited the node before\n                // the continue statement \"jumps over\" one iteration in the loop.\n                continue;\n            } else {\n                history.push(node.id);\n            }\n\n            visited.set(node.id, true);\n\n            // now look into its adjacents\n            for (let id of node.adjacents) {\n                let neighbor = this.getNode(id);\n                stack.push(neighbor);\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if Path exist via Breath First Search\n     * Go wide, and first check all neighbor nodes. (adjacents) before going deep.\n     * Need a Queue for this\n     * @param {GraphNode} source - The Node to start searching from\n     * @param {GraphNode} destination - The Node that needs to be found\n     * @param {SimpleDict} visited - A Simple Dictionary holding the references to the visisted vertices\n     * @returns {boolean} pathExists - return true if a path was found\n     */\n    private _bfs(source: GraphNode, destination: GraphNode, visited: SimpleDict): any {\n        let queue = new Queue();\n        let history = [];\n        queue.add(source);\n\n        while (!queue.isEmpty()) {\n            // as long as there are items in the queue\n            // keep running this\n\n            // get the item from the queue\n            let node = queue.remove();\n\n            // console.log(node.id);\n\n            // the node you are looking for\n            // is the same as the destination\n            if (node === destination) {\n                history.push(node.id);\n                // path of all visited\n                return history;\n            }\n\n            if (visited.hasKey(node.id)) {\n                // you have visited the node before\n                // the continue statement \"jumps over\" one iteration in the loop.\n                continue;\n            } else {\n                    history.push(node.id);\n            }\n\n            visited.set(node.id, true);\n\n            // now look into its adjacents\n            for (let id of node.adjacents) {\n                let neighbor = this.getNode(id);\n                queue.add(neighbor);\n            }\n        }\n\n        return false;\n    }\n}\n","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Sorters.ts\");","/**\n * Array Sorters\n * @class Sorters\n * @author Lee Boonstra\n */\nexport class Sorters {\n\n    public quicksort(array: Array<number>): Array<number> {\n        return this._quicksort(array, 0, array.length - 1);\n    }\n\n    private _quicksort(array: Array<number>, leftPos: number, rightPos: number): Array<number> {\n        if (leftPos === rightPos) {\n            console.log(array);\n            return array;\n        }\n        // let pivot = array[Math.ceil(array.length / 2)];\n        let pivot = rightPos;\n        let index = this._partition(array, leftPos, rightPos, pivot);\n\n        this._quicksort(array, leftPos, index - 1);\n        this._quicksort(array, index, rightPos);\n    }\n\n    private _partition(array: Array<number>, leftPos: number, rightPos: number, pivot: number): number {\n        console.log(array);\n        while (leftPos <= rightPos) {\n         // we will loop through all the items, bringing the\n         // leftPos and the rightPos closer\n\n            while (array[leftPos] < array[pivot]) {\n                leftPos++;\n            }\n\n            while (array[rightPos] > array[pivot]) {\n                rightPos--;\n            }\n\n            if (leftPos < rightPos) {\n                this._swap(array, leftPos, rightPos);\n                leftPos++;\n                rightPos--;\n            } else {\n                return leftPos;\n            }\n\n        }\n\n        return leftPos;\n    }\n\n    private _swap(array: Array<number>, leftPos: number, rightPos: number) {\n        let temp = array[leftPos];\n        array[leftPos] = array[rightPos];\n        array[rightPos] = temp;\n    }\n}","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Searchers.ts\");","/**\n * Array Searchers\n * @class Searchers\n * @author Lee Boonstra\n */\nexport class Searchers {\n\n    /**\n     * Linear Search a search algorithm that works with sorted and unsorted data.\n     * It's basically an interation over the array with a for loop.\n     *\n     * O(n)\n     * @param {Array<any>} array - array with values\n     * @param {string} search - string to be found\n     * @returns {number} position - position of the value in the sorted array.\n     */\n    public linear(array: Array<any>, search: string): number {\n        let position = -1;\n\n        for (let i = 0; i < array.length; i++) {\n            if (array[i] === search) {\n                return i;\n            }\n        }\n\n        return position;\n    }\n\n    /**\n     * Binary Search a search algorithm that only works on sorted data.\n     * The idea is to get the middle as a pivot. See if the desired number\n     * is smaller or greater than the middle. If it's smaller look in the\n     * smaller part. Repeat this proccess till the value is found.\n     * Just create a while loop with the condition start <= end. Keep modifying\n     * the start and end variables with the value of middle.\n     *\n     * O(log(n))\n     * @param {Array<number>} sortedArray - sorted array with numbers\n     * @param {number} value - number to be found\n     * @returns {number} position - position of the value in the sorted array.\n     */\n    public binary(sortedArray: Array<number>, value: number): number {\n        let start = 0;\n        let end = sortedArray.length - 1;\n\n        if (value > sortedArray[end]) return -1;\n\n        while (start <= end) {\n            let middle = Math.floor((start + end) / 2);\n\n            if (sortedArray[middle] === value) {\n                // the value is the same as sortedArray[middle]\n                // so found, set the position.\n                return middle;\n            } else if (value > sortedArray[middle]) {\n                // the value can be found in the right side array\n                start = middle;\n            } else {\n                // the value can be found in the left side of the array\n                end = middle;\n            }\n        }\n    }\n\n}","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./TwoStrings.ts\");","export class SubStringSet {\n    private items: Object;\n    private total: number;\n\n    constructor() {\n        this.items = {};\n        this.total = 0;\n    }\n\n    /**\n     * Add a string to the set, can not be duplicate\n\t * @param {string} value - a string character\n\t * returns {Boolean} isAdded - if value has been added to the set.\n     */\n    add(value: string): Boolean {\n        let isExist = false;\n        // TODO do a check on space.\n        if (!this.has(value)) {\n            this.items[value] = value;\n            this.total++;\n        }\n        return isExist;\n    }\n\n    /**\n     * Check if value exist in the Set\n     * @param {string} value - a string character\n     * returns {Boolean} exists - true if value exists in Set\n     */\n    has(value: string): Boolean {\n        let exists = false;\n        if (this.items.hasOwnProperty(value)) {\n            exists = true;\n        }\n        return exists;\n    }\n\n    /**\n     * Get Size\n     * returns {number} size - total of items in set\n     */\n    size(): number {\n        return this.total;\n    }\n\n    /**\n      * Return a new set with all the common values\n      * @param {Set} otherSet - the otherSet to check on\n      * @returns {Set} newSet - set with similarities\n      */\n      intersection(otherSet: SubStringSet): SubStringSet {\n        let newSet = new SubStringSet();\n\n        for (let myVal in otherSet.items) {\n            if (this.has(myVal)) {\n                newSet.add(myVal);\n            }\n        }\n\n        return newSet;\n      }\n}\n"],"sourceRoot":""}