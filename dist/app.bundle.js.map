{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../node_modules/webpack/buildin/global.js-exposed","webpack:///./ts/datastructures/SimpleDict.ts-exposed","webpack:///./index.ts-exposed","webpack:///../node_modules/webpack/buildin/global.js","webpack:///./index.ts","webpack:///./ts/datastructures/Stack.ts-exposed","webpack:///./ts/datastructures/Stack.ts","webpack:///./ts/datastructures/Queue.ts-exposed","webpack:///./ts/datastructures/Queue.ts","webpack:///./ts/datastructures/LinkedList.ts-exposed","webpack:///./ts/datastructures/LinkedList.ts","webpack:///./ts/datastructures/Set.ts-exposed","webpack:///./ts/datastructures/Set.ts","webpack:///./ts/datastructures/Map.ts-exposed","webpack:///./ts/datastructures/Map.ts","webpack:///./ts/datastructures/HashTable.ts-exposed","webpack:///./ts/datastructures/HashTable.ts","webpack:///./ts/datastructures/SimpleDict.ts","webpack:///./ts/datastructures/Tree.ts-exposed","webpack:///./ts/datastructures/Tree.ts","webpack:///./ts/datastructures/Graph.ts-exposed","webpack:///./ts/datastructures/Graph.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","global","g","this","Function","e","window","Stack_1","Queue_1","LinkedList_1","Set_1","Map_1","HashTable_1","Tree_1","Graph_1","Stack","Queue","LinkedList","Set","Map","HashTable","BinarySearchTree","Graph","[object Object]","items","total","item","undefined","isEmpty","count","Node","node","next","head","last_node","getHead","setHead","index","isInserted","size","newNode","previous","getNodeAt","current","console","log","values","indexOf","removeAt","isRemoved","error","arr","push","isCreated","has","isExisting","parseInt","callback","otherSet","unionSet","forEach","val","set","add","intersection","difference","isSubset","counter","hasKey","toString","SimpleDict_1","opt","table","bucketSize","probe","uniqueKeys","hash","hashCode","hasHash","SimpleDict","keys","constructor","newItem","length","remove","itemValue","charCodeAt","TreeNode","left","right","root","searchTree","find","removeNode","tempNode","leftBranch","getMinHeight","rightBranch","getMaxHeight","array","Array","method","toLowerCase","inorder","preorder","postorder","levelorder","result","traverseInOrder","traversePreOrder","traversePostOrder","results","queue","shift","GraphNode","id","adjacents","nodeIds","matrix","vertices","j","nodeId","startId","destinationId","source","getNode","destination","visited","_hasPathDfs","pathExists"],"mappings":"aACA,IAAAA,EAAA,GAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,GAAA,CACAG,EAAAH,EACAI,GAAA,EACAH,QAAA,IAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,IAAAD,QAAAF,GAGAG,EAAAE,GAAA,EAGAF,EAAAD,QAKAF,EAAAQ,EAAAF,EAGAN,EAAAS,EAAAV,EAGAC,EAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,EAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,EAAA,CAA0CK,YAAA,EAAAC,IAAAL,KAK1CZ,EAAAkB,EAAA,SAAAhB,GACA,oBAAAiB,eAAAC,aACAN,OAAAC,eAAAb,EAAAiB,OAAAC,YAAA,CAAwDC,MAAA,WAExDP,OAAAC,eAAAb,EAAA,cAAiDmB,OAAA,KAQjDrB,EAAAsB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAArB,EAAAqB,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,iBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFA1B,EAAAkB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAArB,EAAAU,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAzB,EAAA6B,EAAA,SAAA1B,GACA,IAAAS,EAAAT,KAAAqB,WACA,WAA2B,OAAArB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAH,EAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD/B,EAAAkC,EAAA,GAIAlC,IAAAmC,EAAA,sBClFA,SAAAC,GAAAjC,EAAAD,QAAAkC,EAAA,QAAqCpC,EAAQ,uCCA7C,SAAAoC,GAAAjC,EAAAD,QAAAkC,EAAA,QAAqCpC,EAAQ,wCCA7C,SAAAoC,GAAAjC,EAAAD,QAAAkC,EAAA,QAAqCpC,EAAQ,oCCA7C,IAAAqC,EAGAA,EAAA,WACA,OAAAC,KADA,GAIA,IAEAD,KAAA,IAAAE,SAAA,iBACC,MAAAC,GAED,iBAAAC,SAAAJ,EAAAI,QAOAtC,EAAAD,QAAAmC,iFCnBA,MAAAK,EAAA1C,EAAA,GACA2C,EAAA3C,EAAA,GACA4C,EAAA5C,EAAA,GACA6C,EAAA7C,EAAA,IACA8C,EAAA9C,EAAA,IACA+C,EAAA/C,EAAA,IACAgD,EAAAhD,EAAA,IACAiD,EAAAjD,EAAA,IAEAG,EAAOD,QAAW,CAAEgD,MAAAR,EAAAQ,MAAOC,MAAAR,EAAAQ,MAAOC,WAAAR,EAAAQ,WAAYC,IAAAR,EAAAQ,IAAKC,IAAAR,EAAAQ,IAAKC,UAAAR,EAAAQ,UAAWC,iBAAAR,EAAAQ,iBAAkBC,MAAAR,EAAAQ,yBCTrF,SAAArB,GAAAjC,EAAAD,QAAAkC,EAAA,QAAqCpC,EAAQ,oGCgB7CE,EAAAgD,MAAA,MAIIQ,cAEIpB,KAAKqB,MAAQ,GAEbrB,KAAKsB,MAAQ,EASjBF,KAAKG,GAGDvB,KAAKqB,MAAMrB,KAAKsB,OAASC,EACzBvB,KAAKsB,QASTF,MACI,IAAIG,OAAOC,EAQX,OAPKxB,KAAKyB,YACNzB,KAAKsB,QAGLC,EAAOvB,KAAKqB,MAAMrB,KAAKsB,cAChBtB,KAAKqB,MAAMrB,KAAKsB,QAEpBC,EASXH,OACI,GAAIpB,KAAKyB,UAAW,OAEpB,IAAI3D,EAAIkC,KAAKsB,MAAQ,EACrB,OAAOtB,KAAKqB,MAAMvD,GAStBsD,UACI,OAAuB,IAAfpB,KAAKsB,MAOjBF,QACSpB,KAAKyB,YACNzB,KAAKqB,MAAQ,GACbrB,KAAKsB,MAAQ,GAUrBF,OAII,OAAOpB,KAAKsB,MAShBF,SACI,OAAOpB,KAAKqB,0BChHpB,SAAAvB,GAAAjC,EAAAD,QAAAkC,EAAA,QAAqCpC,EAAQ,oGCc7CE,EAAAiD,MAAA,MAKIO,cAEIpB,KAAKqB,MAAQ,GAEbrB,KAAKsB,MAAQ,EAGbtB,KAAK0B,MAAQ,EASjBN,IAAIG,GACAvB,KAAKqB,MAAMrB,KAAKsB,OAASC,EACzBvB,KAAKsB,QASTF,SACI,IAAIG,OAAOC,EAYX,OAXKxB,KAAKyB,YAGNF,EAAOvB,KAAKqB,MAAMrB,KAAK0B,cAEhB1B,KAAKqB,MAAMrB,KAAK0B,OAEvB1B,KAAKsB,QAELtB,KAAK0B,SAEFH,EASXH,OACI,IAAIpB,KAAKyB,UAET,OAAOzB,KAAKqB,MAAMrB,KAAK0B,OAS3BN,UACI,OAAuB,IAAfpB,KAAKsB,MAOjBF,QACSpB,KAAKyB,YACNzB,KAAKqB,MAAQ,GACbrB,KAAKsB,MAAQ,EACbtB,KAAK0B,MAAQ,GAUrBN,OAKI,OAAOpB,KAAKsB,MAShBF,SACI,OAAOpB,KAAKqB,0BCrHpB,SAAAvB,GAAAjC,EAAAD,QAAAkC,EAAA,QAAqCpC,EAAQ,qGC0B7C,MAAaiE,EAGTP,YAAYG,GACRvB,KAAK4B,KAAOL,EACZvB,KAAK6B,UAAOL,GALpB5D,EAAA+D,OAmCA/D,EAAAkD,WAAA,MAIIM,cAEIpB,KAAK8B,KAAO,KACZ9B,KAAKsB,MAAQ,EAUjBF,KAAKG,GACD,MAAMK,EAAO,IAAID,EAAKJ,GACtB,IAAIQ,EAEJ,GAAsB,MAAlB/B,KAAKgC,UAELhC,KAAKiC,QAAQL,OACV,CAKH,IAHAG,EAAY/B,KAAKgC,UAGQ,MAAlBD,EAAUF,MACbE,EAAYA,EAAUF,KAG1BE,EAAUF,KAAOD,EAIrB,OAFA5B,KAAKsB,SAEE,EAYXF,OAAOc,EAAeX,GAClB,IAAIY,GAAa,EACjB,GAAID,GAAS,GAAKA,GAASlC,KAAKoC,OAAQ,CACpC,MAAMC,EAAU,IAAIV,EAAKJ,GAEzB,GAAc,IAAVW,EAEAlC,KAAKiC,QAAQI,OAEV,CAGH,IAAIC,EAAWtC,KAAKuC,UAAUL,EAAQ,GAClCM,EAAUF,EAAST,KACvBQ,EAAQR,KAAOW,EACfF,EAAST,KAAOQ,EAGpBI,QAAQC,IAAI1C,KAAK2C,UACjB3C,KAAKsB,aAELa,GAAa,EAGjB,OAAOA,EAQXf,UACI,OAAOpB,KAAK8B,KAQhBV,QAAQQ,GACJ5B,KAAK8B,KAAOF,EAWhBR,QAAQG,GACJ,IAAIW,GAAS,EACTN,EAAO5B,KAAKgC,UAGhB,IAAK,IAAIlE,EAAI,EAAGA,EAAIkC,KAAKsB,OAAiB,MAARM,EAAc9D,IAExCyD,IAASK,EAAKA,OACdM,EAAQpE,GAEZ8D,EAAOA,EAAKC,KAGhB,OAAOK,EAWXd,UAAUc,GACN,IAAIN,OAAOJ,EAEX,GAAIU,GAAS,GAAKA,GAASlC,KAAKsB,MAAO,CACnCM,EAAO5B,KAAKgC,UAGZ,IAAK,IAAIlE,EAAI,EAAGA,EAAIoE,GAAiB,MAARN,EAAc9D,IACvC8D,EAAOA,EAAKC,KAKpB,OAAOD,EAUXR,OAAOG,GACH,IAAIW,EAAQlC,KAAK4C,QAAQrB,GAGzB,OAFavB,KAAK6C,SAASX,GAY/Bd,SAASc,GACL,IAAIY,GAAY,EAChB,GAAIZ,EAAQ,EAERO,QAAQM,MAAM,4DACX,CACH,IAAIP,EAAUxC,KAAKgC,UAEnB,GAAc,IAAVE,EAGAlC,KAAKiC,QAAQO,EAAQX,UAClB,CAGH,IAAIS,EACJ,IAAK,IAAIxE,EAAI,EAAGA,EAAIoE,EAAOpE,IAEvBwE,EAAWE,EAEXA,EAAUA,EAAQX,KAItBS,EAAST,KAAOW,EAAQX,KAG5B7B,KAAKsB,QACLwB,GAAY,EAEhB,OAAOA,EASX1B,OAII,OAAOpB,KAAKsB,MAQhBF,UACI,OAAuB,IAAfpB,KAAKsB,MASjBF,SACI,IAAI4B,EAAM,GACV,GAAoB,MAAhBhD,KAAKgC,QAAiB,CACtB,IAAIJ,EAAO5B,KAAKgC,UAChB,IAAK,IAAIlE,EAAI,EAAGA,EAAIkC,KAAKoC,QAAkB,MAARR,EAAc9D,IAC7CkF,EAAIC,KAAKrB,GAETA,EAAOA,EAAKC,KAGpB,OAAOmB,sBCvSf,SAAAlD,GAAAjC,EAAAD,QAAAkC,EAAA,QAAqCpC,EAAQ,qGCgB7C,MAAaqD,EAITK,cACIpB,KAAKqB,MAAQ,GACbrB,KAAKsB,MAAQ,EAQjBF,IAAIrC,GACA,IAAImE,GAAY,EAMhB,OALKlD,KAAKmD,IAAIpE,KACViB,KAAKqB,MAAMrB,KAAKsB,OAASvC,EACzBmE,GAAY,EACZlD,KAAKsB,SAEF4B,EAQX9B,OAAOrC,GACH,IAAI+D,GAAY,EAMhB,OALI9C,KAAKmD,IAAIpE,YACFiB,KAAKqB,MAAMtC,GAClB+D,GAAY,EACZ9C,KAAKsB,SAEFwB,EAUX1B,IAAIrC,GACA,IAAIqE,GAAa,EACjB,IAAK,IAAI/D,KAAOW,KAAKqB,MAEbrB,KAAKqB,MAAM1B,eAAeN,IACrBW,KAAKqB,MAAMhC,KAASN,GAChBsE,SAAShE,IAAQW,KAAKoC,SACvBgB,GAAa,GAK7B,OAAOA,EAQXhC,OACI,IAAI4B,EAAM,GACV,IAAK,IAAIzB,KAAQvB,KAAKqB,MAClB2B,EAAIC,KAAK1B,GAGb,OAAOyB,EAQX5B,SACI,IAAI4B,EAAM,GACV,IAAK,IAAIzB,KAAQvB,KAAKqB,MAClB2B,EAAIC,KAAKjD,KAAKqB,MAAME,IAGxB,OAAOyB,EAMX5B,QACIpB,KAAKqB,MAAQ,GACbrB,KAAKsB,MAAQ,EAQjBF,OACI,OAAOpB,KAAKsB,MAQhBF,QAAQkC,GACJ,IAAK,IAAIjE,KAAOW,KAAKqB,MACjBiC,EAASjE,EAAKW,KAAKqB,MAAMhC,GAAMW,KAAKqB,OAU5CD,UACI,OAAuB,IAAfpB,KAAKsB,MASjBF,MAAMmC,GACF,IAAIC,EAAW,IAAIzC,EASnB,OAPAf,KAAKyD,QAAQ,SAASpE,EAAaqE,EAAaC,GAC5CH,EAASI,IAAIF,KAEjBH,EAASE,QAAQ,SAASpE,EAAaqE,EAAaC,GAChDH,EAASI,IAAIF,KAGVF,EASXpC,aAAamC,GACT,IAAIM,EAAe,IAAI9C,EAOvB,OALAf,KAAKyD,QAAQ,SAASpE,EAAaqE,EAAaC,GACxCJ,EAASJ,IAAIO,IACbG,EAAaD,IAAIF,KAGlBG,EAUXzC,WAAWmC,GACP,IAAIO,EAAa,IAAI/C,EAQrB,OANAf,KAAKyD,QAAQ,SAASpE,EAAaqE,EAAaC,GACvCJ,EAASJ,IAAIO,IACdI,EAAWF,IAAIF,KAIhBI,EASX1C,SAASmC,GACL,IAAIQ,GAAW,EACXC,EAAU,EAkBd,OAfIhE,KAAKoC,QAAUmB,EAASnB,QAIxBpC,KAAKyD,QAAQ,SAASpE,EAAaqE,EAAaC,GACxCJ,EAASJ,IAAIO,IACbM,MAKRA,IAAYhE,KAAKoC,SACjB2B,GAAW,GAGRA,GAhNfnG,EAAAmD,wBChBA,SAAAjB,GAAAjC,EAAAD,QAAAkC,EAAA,QAAqCpC,EAAQ,qGCa7CE,EAAAoD,IAAA,MAIII,cACIpB,KAAKqB,MAAQ,GACbrB,KAAKsB,MAAQ,EASjBF,IAAI/B,EAAaN,GACb,IAAImE,GAAY,EAMhB,OALKlD,KAAKiE,OAAO5E,EAAI6E,cACjBlE,KAAKqB,MAAMhC,GAAON,EAClBmE,GAAY,EACZlD,KAAKsB,SAEF4B,EAQX9B,OAAO/B,GACH,IAAIyD,GAAY,EAMhB,OALI9C,KAAKiE,OAAO5E,EAAI6E,qBACTlE,KAAKqB,MAAMhC,GAClByD,GAAY,EACZ9C,KAAKsB,SAEFwB,EAUX1B,OAAO/B,GACH,IAAI+D,GAAa,EAIjB,OAHIpD,KAAKqB,MAAMhC,KACX+D,GAAa,GAEVA,EASXhC,IAAI/B,GACA,OAAOW,KAAKqB,MAAMhC,EAAI6E,YAQ1B9C,OACI,IAAI4B,EAAM,GACV,IAAK,IAAIzB,KAAQvB,KAAKqB,MAClB2B,EAAIC,KAAK1B,GAGb,OAAOyB,EAQX5B,SACI,IAAI4B,EAAM,GACV,IAAK,IAAIzB,KAAQvB,KAAKqB,MAClB2B,EAAIC,KAAKjD,KAAKqB,MAAME,IAGxB,OAAOyB,EAMX5B,QACIpB,KAAKqB,MAAQ,GACbrB,KAAKsB,MAAQ,EAQjBF,OACI,OAAOpB,KAAKsB,MAShBF,UACI,OAAuB,IAAfpB,KAAKsB,MASjBF,QAAQkC,GACJ,IAAK,IAAIjE,KAAOW,KAAKqB,MACjBiC,EAASjE,EAAKW,KAAKqB,MAAMhC,GAAMW,KAAKqB,2BC7IhD,SAAAvB,GAAAjC,EAAAD,QAAAkC,EAAA,QAAqCpC,EAAQ,qGCA7C,MAAAyG,EAAAzG,EAAA,GAmCAE,EAAAqD,UAAA,MAaIG,YAAYgD,GACRpE,KAAKqE,MAAQ,GACbrE,KAAKsB,MAAQ,EACbtB,KAAKsE,WAAcF,EAAIE,YAAc,EACrCtE,KAAKuE,MAASH,EAAIG,QAAS,EAC3BvE,KAAKwE,WAAcJ,EAAII,aAAc,EASzCpD,IAAI/B,EAAaN,GACb,IAAImE,GAAY,EACZuB,EAAOzE,KAAK0E,SAASrF,GACzB,GAAKW,KAAK2E,QAAQF,GAMd,GAAIzE,KAAKuE,MAAO,CACZ,IAAIrC,EAAQuC,EAAO,EACnB,UAA6BjD,IAAtBxB,KAAKqE,MAAMnC,IACdA,IAEJlC,KAAKqE,MAAMnC,GAAS,IAAIiC,EAAAS,WACxB5E,KAAKqE,MAAMnC,GAAOyB,IAAItE,EAAKN,GAC3BmE,GAAY,EACZlD,KAAKsB,aAGL,GAAItB,KAAKwE,YAAcxE,KAAKqE,MAAMI,GAAMI,KAAK,KAAOxF,EAGhDoD,QAAQM,MAAM1D,EAAM,iDACjB,CAEH,GAAIW,KAAKqE,MAAMI,GAAMK,cAAgBX,EAAAS,WAAY,CAC7C,IAAIpC,EAAUxC,KAAKqE,MAAMI,GACzBzE,KAAKqE,MAAMI,GAAQ,GACnBzE,KAAKqE,MAAMI,GAAMxB,KAAKT,GAG1B,IAAIuC,EAAU,IAAIZ,EAAAS,WAClBG,EAAQpB,IAAItE,EAAKN,GACjBiB,KAAKqE,MAAMI,GAAMxB,KAAK8B,GACtB7B,GAAY,EACZlD,KAAKsB,aAhCbtB,KAAKqE,MAAMI,GAAQ,IAAIN,EAAAS,WACvB5E,KAAKqE,MAAMI,GAAMd,IAAItE,EAAKN,GAC1BmE,GAAY,EACZlD,KAAKsB,QAkCT,OAAO4B,EAWX9B,OAAO/B,GACH,IAAIyD,GAAY,EACZ2B,EAAOzE,KAAK0E,SAASrF,GAIzB,GAAIW,KAAKuE,OAAUvE,KAAKqE,MAAMW,SAAWhF,KAAKsE,WAAa,CACvD,IAAIpC,EAAQuC,EAEZ,KAAOzE,KAAKqE,MAAMnC,GAAO2C,KAAK,KAAOxF,GACjC6C,IAEJlC,KAAKqE,MAAMnC,GAAO+C,OAAO5F,GACzByD,GAAY,EACZ9C,KAAKsB,aAELtB,KAAKqE,MAAMI,GAAMQ,OAAO5F,GACxByD,GAAY,EACZ9C,KAAKsB,QAGT,OAAOwB,EAUX1B,QAAQqD,GACJ,IAAIrB,GAAa,EAIjB,OAHIpD,KAAKqE,MAAMI,KACXrB,GAAa,GAEVA,EAUXhC,IAAI/B,GACA,IAAIoF,EAAOzE,KAAK0E,SAASrF,GACrB6F,OAAY1D,EAKhB,GAAIxB,KAAKuE,OAAUvE,KAAKqE,MAAMW,SAAWhF,KAAKsE,WAAa,CACvD,IAAIpC,EAAQuC,EAEZ,KAAOzE,KAAKqE,MAAMnC,GAAO2C,KAAK,KAAOxF,GACjC6C,IAEJgD,EAAYlF,KAAKqE,MAAMnC,GAAOvD,IAAIU,QAElC,GAAIW,KAAKqE,MAAMI,GAAMK,cAAgBX,EAAAS,WACjCM,EAAYlF,KAAKqE,MAAMI,GAAM9F,IAAIU,OAC9B,CAGH,IAAIvB,EAAI,EACR,KAAOuB,IAAQW,KAAKqE,MAAMI,GAAM3G,GAAG+G,KAAK,IACpC/G,IAEJoH,EAAYlF,KAAKqE,MAAMI,GAAM3G,GAAGa,IAAIU,GAI5C,OAAO6F,EAMX9D,QACIpB,KAAKqE,MAAQ,GACbrE,KAAKsB,MAAQ,EAQjBF,OACI,OAAOpB,KAAKsB,MAShBF,UACI,OAAuB,IAAfpB,KAAKsB,MAQjBF,QAAQkC,GACJ,IAAK,IAAIjE,KAAOW,KAAKqE,MACjBf,EAASjE,EAAKW,KAAKqE,MAAMhF,GAAMW,KAAKqE,OAc5CjD,SAAS/B,GACL,IAAIoF,EAAO,EAEX,IAAK,IAAI3G,EAAI,EAAGA,EAAIuB,EAAI2F,OAAQlH,IAC9B2G,GAFW,GAEIA,EAAOpF,EAAI8F,WAAWrH,GAKvC,OAHwB,IAApBkC,KAAKsE,aACLG,GAAczE,KAAKsE,YAEhBG,mFChPf7G,EAAAgH,WAAA,MAKIxD,cACIpB,KAAK6E,KAAO,GACZ7E,KAAK2C,OAAS,GACd3C,KAAKsB,MAAQ,EAUjBF,IAAI/B,EAAaN,GAKb,OAJAiB,KAAK6E,KAAK5B,KAAK5D,GACfW,KAAK2C,OAAOM,KAAKlE,GACjBiB,KAAKsB,SAEE,EASXF,OAAO/B,GACH,IAAIyD,GAAY,EAChB,IAAK,IAAIhF,EAAI,EAAGA,EAAIkC,KAAK6E,KAAKG,OAAQlH,IAC9BkC,KAAK6E,KAAK/G,KAAOuB,WACVW,KAAK6E,KAAK/G,UACVkC,KAAK2C,OAAO7E,GACnBkC,KAAKsB,QACLwB,GAAY,GAGpB,OAAOA,EASX1B,IAAI/B,GACA,IAAK,IAAIvB,EAAI,EAAGA,EAAIkC,KAAK6E,KAAKG,OAAQlH,IAClC,GAAIkC,KAAK6E,KAAK/G,KAAOuB,EACjB,OAAOW,KAAK2C,OAAO7E,GAY/BsD,OAAO/B,GACH,IAAI+D,GAAa,EAIjB,OAHIpD,KAAK6E,KAAKxF,KACV+D,GAAa,GAEVA,EAQXhC,OACI,OAAOpB,KAAKsB,MAQhBF,UACI,OAAsB,IAAfpB,KAAKsB,MAQhBF,QAII,OAHApB,KAAK6E,KAAO,GACZ7E,KAAK2C,OAAS,GACd3C,KAAKsB,MAAQ,EACNtB,KAAKsB,0BC7GpB,SAAAxB,GAAAjC,EAAAD,QAAAkC,EAAA,QAAqCpC,EAAQ,qGCM7C,MAAa0H,EAKThE,YAAY/B,EAAagG,EAAiB,KAAMC,EAAkB,MAC9DtF,KAAKX,IAAMA,EACXW,KAAKqF,KAAOA,EACZrF,KAAKsF,MAAQA,GARrB1H,EAAAwH,WA8CAxH,EAAAsD,iBAAA,MAGIE,cACIpB,KAAKuF,KAAO,KAUhBnE,mBACI,IAAI/B,EAAM,KAIV,OAHkB,OAAdW,KAAKuF,OACLlG,EAAMW,KAAKuF,KAAKlG,KAEbA,EAOX+B,OAAO/B,GACH,MAAMuC,EAAO5B,KAAKuF,KAClB,GAAY,MAAR3D,EAKG,CAKH,MAAM4D,EAAa,SAAS5D,GAExB,GAAIvC,EAAMuC,EAAKvC,IAAK,CAGhB,GAAiB,MAAbuC,EAAKyD,KAGL,YADAzD,EAAKyD,KAAO,IAAID,EAAS/F,IAEJ,OAAduC,EAAKyD,MAIZG,EAAW5D,EAAKyD,WAEjB,GAAIhG,EAAMuC,EAAKvC,IAAK,CAGvB,GAAkB,MAAduC,EAAK0D,MAGL,YADA1D,EAAK0D,MAAQ,IAAIF,EAAS/F,IAEvB,GAAmB,OAAfuC,EAAK0D,MAQZ,OAAO,KAJPE,EAAW5D,EAAK0D,SAS5B,OAAOE,EAAW5D,GA1ClB5B,KAAKuF,KAAO,IAAIH,EAAS/F,GAiDjC+B,MACI,IAAIoB,EAAUxC,KAAKuF,KAGnB,KAAwB,OAAjB/C,EAAQ6C,WAAkC7D,IAAjBgB,EAAQ6C,MACpC7C,EAAUA,EAAQ6C,KAEtB,OAAO7C,EAAQnD,IAMnB+B,MACI,IAAIoB,EAAUxC,KAAKuF,KAGnB,KAAwB,MAAjB/C,EAAQ8C,OACX9C,EAAUA,EAAQ8C,MAEtB,OAAO9C,EAAQnD,IASnB+B,SAAS/B,GACL,OAA2B,OAAnBW,KAAKyF,KAAKpG,GAStB+B,KAAK/B,GACD,IAAImD,EAAUxC,KAAKuF,KAEnB,KAAO/C,GAAS,CAEZ,GAAInD,IAAQmD,EAAQnD,IAEhB,OAAOmD,EAIPA,EAHOnD,EAAMmD,EAAQnD,IAGXmD,EAAQ6C,KAIR7C,EAAQ8C,MAK1B,OAAO,KAOXlE,OAAO/B,GACH,MAAMqG,EAAa,SAAS9D,EAAgBvC,GACxC,GAAY,MAARuC,EAEA,OAAO,KAGX,GAAIvC,IAAQuC,EAAKvC,IAAK,CAQlB,GAAkB,OAAduC,EAAKyD,MAAgC,OAAfzD,EAAK0D,MAC3B,OAAO,KASX,GAAkB,OAAd1D,EAAKyD,KACL,OAAOzD,EAAK0D,MAShB,GAAmB,OAAf1D,EAAK0D,MACL,OAAO1D,EAAKyD,KAWhB,IAAIM,EAAW/D,EAAK0D,MAGpB,KAAyB,OAAlBK,EAASN,MACZM,EAAWA,EAASN,KAWxB,OANAzD,EAAKvC,IAAMsG,EAAStG,IAKpBuC,EAAK0D,MAAQI,EAAW9D,EAAK0D,MAAOK,EAAStG,KACtCuC,EACJ,OAAIvC,EAAMuC,EAAKvC,KAClBuC,EAAKyD,KAAOK,EAAW9D,EAAKyD,KAAMhG,GAC3BuC,IAEPA,EAAK0D,MAAQI,EAAW9D,EAAK0D,MAAOjG,GAC7BuC,IAIf5B,KAAKuF,KAAOG,EAAW1F,KAAKuF,KAAMlG,GAUtC+B,aAAaQ,EAAO5B,KAAKuF,MACrB,GAAY,MAAR3D,EAGA,OAAQ,EAOZ,IAAIgE,EAAa5F,KAAK6F,aAAajE,EAAKyD,MACpCS,EAAc9F,KAAK6F,aAAajE,EAAK0D,OASzC,OAAIM,EAAaE,EACNF,EAAa,EAEbE,EAAc,EAS7B1E,aAAaQ,EAAO5B,KAAKuF,MACrB,GAAY,MAAR3D,EAGA,OAAQ,EAOZ,IAAIgE,EAAa5F,KAAK+F,aAAanE,EAAKyD,MACpCS,EAAc9F,KAAK+F,aAAanE,EAAK0D,OASzC,OAAIM,EAAaE,EACNF,EAAa,EAEbE,EAAc,EAQ7B1E,aACI,OAAOpB,KAAK6F,gBACL7F,KAAK+F,eAAiB,EASjC3E,SAASgD,GACL,IAAI4B,EAAQ,IAAIC,MACZC,EAAS,GAKb,OAJI9B,EAAI8B,SACJA,EAAS9B,EAAI8B,OAAOC,eAExB1D,QAAQC,IAAIwD,GACJA,GACJ,IAAK,UACDF,EAAQhG,KAAKoG,UACb,MACJ,IAAK,WACDJ,EAAQhG,KAAKqG,WACb,MACJ,IAAK,YACDL,EAAQhG,KAAKsG,YACb,MACJ,IAAK,aACDN,EAAQhG,KAAKuG,aACb,MACJ,QACIP,EAAQhG,KAAKoG,UAGrB,OAAOJ,EAOX5E,UACI,GAAiB,MAAbpB,KAAKuF,KAKL,OADA9C,QAAQC,IAAI,eACL,KACJ,CACH,IAAI8D,EAAS,IAAIP,MA8BjB,OA5BA,SAASQ,EAAgB7E,GAQrBA,EAAKyD,MAAQoB,EAAgB7E,EAAKyD,MAOlCmB,EAAOvD,KAAKrB,EAAKvC,KAUjBuC,EAAK0D,OAASmB,EAAgB7E,EAAK0D,OAEvCmB,CAAgBzG,KAAKuF,MACdiB,GAQfpF,WACI,GAAiB,MAAbpB,KAAKuF,KAIL,OAAO,KACJ,CACH,IAAIiB,EAAS,IAAIP,MAajB,OAXA,SAASS,EAAiB9E,GAEtB4E,EAAOvD,KAAKrB,EAAKvC,KAGjBuC,EAAKyD,MAAQqB,EAAiB9E,EAAKyD,MAGnCzD,EAAK0D,OAASoB,EAAiB9E,EAAK0D,OAExCoB,CAAiB1G,KAAKuF,MACfiB,GAQfpF,YACI,GAAiB,MAAbpB,KAAKuF,KAIL,OAAO,KACJ,CACH,IAAIiB,EAAS,IAAIP,MAajB,OAXA,SAASU,EAAkB/E,GAGvBA,EAAKyD,MAAQsB,EAAkB/E,EAAKyD,MAGpCzD,EAAK0D,OAASqB,EAAkB/E,EAAK0D,OAErCkB,EAAOvD,KAAKrB,EAAKvC,KAErBsH,CAAkB3G,KAAKuF,MAChBiB,GAQfpF,aACI,IAAIwF,EAAU,GACVC,EAAQ,GACZ,GAAiB,MAAb7G,KAAKuF,KAAc,CAKnB,IAJAsB,EAAM5D,KAAKjD,KAAKuF,MAITsB,EAAM7B,OAAS,GAAG,CACrB,IAAIpD,EAAOiF,EAAMC,QAQjBF,EAAQ3D,KAAKrB,EAAKvC,KAED,MAAbuC,EAAKyD,MAKLwB,EAAM5D,KAAKrB,EAAKyD,MAEF,MAAdzD,EAAK0D,OAMLuB,EAAM5D,KAAKrB,EAAK0D,OAQxB,OAAOsB,EAEP,OAAO,yBCnhBnB,SAAA9G,GAAAjC,EAAAD,QAAAkC,EAAA,QAAqCpC,EAAQ,qGCC7C,MAAAyG,EAAAzG,EAAA,GAQA,MAAaqJ,EAIT3F,YAAY4F,GACRhH,KAAKgH,GAAKA,EACVhH,KAAKiH,UAAY,IAAIhB,OAN7BrI,EAAAmJ,YAiBAnJ,EAAAuD,MAAA,MAMIC,YAAa8F,EAAaC,GAOtB,GANAnH,KAAKmH,OAASA,EACdnH,KAAKkH,QAAUA,EACflH,KAAKoH,SAAW,GAChBpH,KAAKgE,QAAU,EAGXkD,EAAQlC,SAAWhF,KAAKmH,OAAOnC,OAC/B,KAAM,+DAIV,IAAK,IAAIlH,EAAI,EAAGA,EAAIqJ,EAAOnC,OAAQlH,IAAK,CAEpC,IAAI8D,EAAO,IAAImF,EAAU/G,KAAKkH,QAAQpJ,IAGtC,IAAK,IAAIuJ,EAAI,EAAGA,EAAIrH,KAAKmH,OAAOrJ,GAAGkH,OAAQqC,IAGlB,IAAjBF,EAAOrJ,GAAGuJ,IACVzF,EAAKqF,UAAUhE,KAAKjD,KAAKkH,QAAQG,IAKzCrH,KAAKoH,SAASxF,EAAKoF,IAAMpF,EAG7Ba,QAAQC,IAAI1C,KAAKoH,UAUrBhG,QAAQkG,GACJ,OAAOtH,KAAKoH,SAASE,GAGzBlG,WAOAA,WAYOA,WAAWmG,EAAiBC,GAC/B,IACIC,EAASzH,KAAK0H,QAAQH,GACtBI,EAAc3H,KAAK0H,QAAQF,GAC3BI,EAAU,IAAIzD,EAAAS,WAIlB,OAFA5E,KAAK6H,YAAYJ,EAAQE,EAAaC,IALrB,EAmBbxG,YAAYqG,EAAmBE,EAAwBC,GAC3D,IAAIE,GAAa,EAEjB,GADA9H,KAAKgE,UACgB,KAAjBhE,KAAKgE,QAAgB,OAAO,EAEhCvB,QAAQC,IAAI+E,GACZhF,QAAQC,IAAIkF,GACZnF,QAAQC,IAAIkF,EAAQ3D,OAAOwD,EAAOT,KAC9BY,EAAQ3D,OAAOwD,EAAOT,IAItBc,GAAa,EAEbF,EAAQjE,IAAI8D,EAAOT,IAAI,GAKvBS,IAAWE,IACXG,GAAa,GAIjB,IAAK,IAAI5F,KAASuF,EAAOR,UAAW,CAChC,IAAIrF,EAAO5B,KAAK0H,QAAQ1H,KAAKkH,QAAQhF,IAErClC,KAAK6H,YAAYjG,EAAM+F,EAAaC,GAGxC,OAAOE,EAQX1G,WAAWmG,EAAiBC,GAKxB,OAJiB","file":"app.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = global[\"Library\"] = require(\"-!./global.js\");","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./SimpleDict.ts\");","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./index.ts\");","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import { Stack } from \"./ts/datastructures/Stack\";\nimport { Queue } from \"./ts/datastructures/Queue\";\nimport { LinkedList } from \"./ts/datastructures/LinkedList\";\nimport { Set } from \"./ts/datastructures/Set\";\nimport { Map } from \"./ts/datastructures/Map\";\nimport { HashTable } from \"./ts/datastructures/HashTable\";\nimport { BinarySearchTree } from \"./ts/datastructures/Tree\";\nimport { Graph } from \"./ts/datastructures/Graph\";\n\nmodule.exports =  { Stack, Queue, LinkedList, Set, Map, HashTable, BinarySearchTree, Graph }\n","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Stack.ts\");","/**\n * Stack Data Structure\n * @class Stack\n * @author Lee Boonstra\n *\n *      # What do we know about Stacks?\n *      It's a sequential data structure with LIFO. Last In - First Out principle.\n *      (and FILO First in - Last Out)\n *      Compare this to a deck of cards. The last card on top, is the first\n *      card to be removed from the pile. The base card, will be last.\n *\n *      ## Real world examples in Software Engineering?\n *      The browser history. Clipboard history.\n *      In the Sencha Ext JS framework there was a card layout / animation.\n *      The deck of cards in Hearthstone.\n */\nexport class Stack {\n    private items: any[];\n    private total: number;\n\n    constructor() {\n        // Based on an Array\n        this.items = [];\n        // Set the total to 0;\n        this.total = 0;\n    }\n\n    /**\n     * Add a new item to the top of the stack.\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @param {any} item - item\n     */\n    push(item: any) {\n        // this.items.push(item);\n        // We can only add one at a time\n        this.items[this.total] = item;\n        this.total++;\n    }\n\n    /**\n     * Pops / Removes the top item from the stack.\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @return {any} item - removed item\n     */\n    pop(): any {\n        let item = undefined;\n        if (!this.isEmpty()) {\n            this.total--;\n            // return this.items.pop();\n            // manual remove\n            item = this.items[this.total];\n            delete this.items[this.total];\n        }\n        return item;\n    }\n\n    /**\n    * Return the top item from the stack.\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return {item} item - top item\n    */\n    peek(): any {\n        if (this.isEmpty()) return undefined;\n\n        let i = this.total - 1;\n        return this.items[i];\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @returns {boolean} isEmpty - if the Stack is empty or not\n    */\n    isEmpty(): Boolean {\n        return (this.total === 0);\n    }\n\n    /**\n    * Removes all the items from the Stack\n    * Take O(1) time. We do not run any loop in any of these operations.\n    */\n    clear() {\n        if (!this.isEmpty()) {\n            this.items = [];\n            this.total = 0;\n        }\n    }\n\n    /**\n    * Return the total number of items from the stack\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return {number} size - total length of Stack\n    */\n    size(): number {\n        // Note: in this example this.items.length would be wrong\n        // since we are removing values from the array\n        // the array is not shifting.\n        return this.total;\n    }\n\n    /**\n     * Print stack\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @return {array} - array with items\n     */\n    values(): any[] {\n        return this.items;\n    }\n}\n","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Queue.ts\");","/**\n * Queue Data Structure\n * @class Queue\n * @author Lee Boonstra\n *\n *      # What do we know about Queues?\n *      It's a sequential data structure with FIFO. First In - First Out principle.\n *      (and LILO Last in - Last Out)\n *      Compare this to the line in at the bakery. First person in the line, takes\n *      a ticket from the counting machine, and will be served first, based on the counter.\n *\n *      ## Real world examples in Software Engineering?\n *      Printer Queue.\n */\nexport class Queue {\n    private items: any[];\n    private total: number; // total items in the queue\n    private count: number; // item count who will be served first\n\n    constructor() {\n        // Based on an Array\n        this.items = [];\n        // Set the total to 0\n        this.total = 0;\n        // Set the count to 0\n        // Compared to Stacks, this is what makes this class different!\n        this.count = 0;\n    }\n\n    /**\n     * Add a new item to the back of the queue.\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @param item any\n     */\n    add(item: any) {\n        this.items[this.total] = item;\n        this.total++;\n    }\n\n    /**\n     * Retrieves and removes the head of this queue.\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @return removed item\n     */\n    remove(): any {\n        let item = undefined;\n        if (!this.isEmpty()) {\n            // which item will be first in the queue\n            // is is based on the counting system\n            item = this.items[this.count];\n            // remove this item from the queue\n            delete this.items[this.count];\n            // the queue size is now shorter\n            this.total--;\n            // but the number counter goes up\n            this.count++;\n        }\n        return item;\n    }\n\n    /**\n    * Return the the head of the queue\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return removed item\n    */\n    peek(): any {\n        if (this.isEmpty()) return undefined;\n\n        return this.items[this.count];\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return Boolean\n    */\n    isEmpty(): Boolean {\n        return (this.total === 0);\n    }\n\n    /**\n    * Removes all the items from the Stack\n    * Take O(1) time. We do not run any loop in any of these operations.\n    */\n    clear() {\n        if (!this.isEmpty()) {\n            this.items = [];\n            this.total = 0;\n            this.count = 0; // reset counter\n        }\n    }\n\n    /**\n    * Return the total number of items from the stack\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return number\n    */\n    size(): number {\n        // Note: in this example this.items.length would be wrong\n        // since we are removing values from the array\n        // the array is not shifting.\n\n        return this.total;\n    }\n\n    /**\n     * Print stack\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @return items\n     */\n    values(): any[] {\n        return this.items;\n    }\n}\n","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./LinkedList.ts\");","/**\n * LinkedList Data Structure\n * @class Node\n * @author Lee Boonstra\n *\n *      # What do we know about LinkedLists?\n *\n *      It's a sequential data structure and has\n *      similarities with an Array (also called a List).\n *      In other languages, an Array has a predefined\n *      size. Inserting and Removing items can be\n *      expensive. Because elements needs to be shifted\n *      over. A LinkedList is a dynamic data structure. We\n *      can add and remove items from it and it will grow\n *      when required. Elements are not placed\n *      contiguously in memory. Each node stores the\n *      element itself and also a reference (pointer\n *      link). Think about this as christmas lights. In\n *      order to find a broken light, you have to visit\n *      each light from beginning (head) to end (tail).\n *\n *      ## Real world examples in Software Engineering?\n *\n *      History and Subversioning? A trial of revisions\n *      and you can add branches?\n */\nexport class Node {\n    public node: Node;\n    public next: Node; // pointer\n    constructor(item: any) {\n        this.node = item;\n        this.next = undefined;\n    }\n}\n\n/**\n * LinkedList Data Structure\n * @class LinkedList\n * @author Lee Boonstra\n *\n *      # What do we know about LinkedLists?\n *\n *      It's a sequential data structure and has\n *      similarities with an Array (also called a List).\n *      In other languages, an Array has a predefined\n *      size. Inserting and Removing items can be\n *      expensive. Because elements needs to be shifted\n *      over. A LinkedList is a dynamic data structure. We\n *      can add and remove items from it and it will grow\n *      when required. Elements are not placed\n *      contiguously in memory. Each node stores the\n *      element itself and also a reference (pointer\n *      link). Think about this as christmas lights. In\n *      order to find a broken light, you have to visit\n *      each light from beginning (head) to end (tail).\n *\n *      ## Real world examples in Software Engineering?\n *\n *      History and Subversioning? A trial of revisions\n *      and you can add branches?\n */\nexport class LinkedList {\n    private head: Node;\n    private total: number;\n\n    constructor() {\n        // when you create a LinkedList the head is empty\n        this.head = null;\n        this.total = 0;\n    }\n\n    /**\n    * Add new item to the end of the LinkedList\n    * Take O(n) time. Loop to figure out the last node.\n    *\n    * @param item: any\n    * @return isAdded Boolean\n    */\n    push(item: any): Boolean {\n        const node = new Node(item);\n        let last_node;\n\n        if (this.getHead() == null) {\n            // the list is empty, adding a new item\n            this.setHead(node);\n        } else {\n            // the list is not empty, append items\n            last_node = this.getHead();\n            // start from the head, keep iterating, till\n            // you find the last node (tail, which is the node with next = null)\n            while (last_node.next != null) {\n                last_node = last_node.next;\n            }\n\n            last_node.next = node;\n        }\n        this.total++;\n\n        return true;\n    }\n\n    /**\n    * Insert a new item at a specified position in the\n    * LinkedList.\n    * Take O(n) time. To find the previous node, we will need to loop.\n    *\n    * @param index: number\n    * @param item: any\n    * @return isInserted Boolean\n    */\n    insert(index: number, item: any): Boolean {\n        let isInserted = false;\n        if (index >= 0 && index <= this.size()) {\n            const newNode = new Node(item);\n\n            if (index === 0) {\n                // This will be the head node.\n                this.setHead(newNode);\n                // update all the references\n            } else {\n                // iterate through all the nodes before the to be added node.\n                // and set a pointer to the next node\n                let previous = this.getNodeAt(index - 1);\n                let current = previous.next;\n                newNode.next = current;\n                previous.next = newNode;\n            }\n\n            console.log(this.values());\n            this.total++;\n        } else {\n            isInserted = false;\n        }\n\n        return isInserted;\n    }\n\n   /**\n    * Get the very first item in the LinkedList\n    *\n    * @return head: Node\n    */\n    getHead(): Node {\n        return this.head;\n    }\n\n  /**\n    * Set the very first item in the LinkedList\n    *\n    * @param node: Node\n    */\n    setHead(node: Node): void {\n        this.head = node;\n    }\n\n   /**\n    * Get the index of a specific node in the\n    * LinkedList. Returns -1 if it doesn't exist.\n    * Take O(n) time. To find the item, you will need to visit all the nodes\n    *\n    * @param node\n    * @return index: number | -1\n    */\n    indexOf(item: any): number {\n        let index = -1;\n        let node = this.getHead();\n        // keep iterating through the total amount of nodes\n        // till you reach the end (node = null and total)\n        for (let i = 0; i < this.total && node != null; i++) {\n            // this should be the one\n            if (item === node.node) {\n                index = i;\n            }\n            node = node.next;\n        }\n\n        return index;\n    }\n\n    /**\n    * Get the item of a specific index in the\n    * LinkedList. Returns undefined if it doesn't exist.\n    * Take O(n) time. To find the item, you will need to visit all the nodes\n    *\n    * @param index: number\n    * @return node: Node | undefined\n    */\n    getNodeAt(index: number): Node {\n        let node = undefined;\n\n        if (index >= 0 && index <= this.total) {\n            node = this.getHead();\n\n            // keep iterating till you reach the index\n            for (let i = 0; i < index && node != null; i++) {\n                node = node.next;\n            }\n\n        }\n\n        return node;\n    }\n\n    /**\n     * Removes an item from the LinkedList.\n     * Take O(n) time. To find the item to be removed, you will need to visit all the nodes\n     *\n     * @param item: any\n     * @return isRemoved Boolean\n     */\n    remove(item: any): Boolean {\n        let index = this.indexOf(item);\n        let result = this.removeAt(index);\n\n        return result;\n    }\n\n    /**\n     * Removes item from a specified index in the LinkedList.\n     * Take O(n) time. To find the item to be removed, you will need to visit all the nodes.\n     *\n     * @param position: number\n     * @return isRemoved Boolean\n     */\n    removeAt(index: number): Boolean {\n        let isRemoved = false;\n        if (index < 0) {\n            // throw \"Can't remove, because item is not in the LinkedList.\";\n            console.error(\"Can't remove, because item is not in the LinkedList.\");\n        } else {\n            let current = this.getHead();\n\n            if (index === 0 ) {\n                // this is the very first node\n                // remove (and update all positions)\n                this.setHead(current.next);\n            } else {\n                // iterate through all the nodes before the to be removed node.\n                // and set a pointer to the next node\n                let previous;\n                for (let i = 0; i < index; i++) {\n                    // temp store the one before\n                    previous = current;\n                    // go to the next node\n                    current = current.next;\n                }\n                // now let remove the reference of the previous node\n                // to skip it, and go to the next one.\n                previous.next = current.next;\n            }\n\n            this.total--;\n            isRemoved = true;\n        }\n        return isRemoved;\n    }\n\n    /**\n    * Return the total number of items from the stack\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return number\n    */\n    size() {\n        // Note: in this example this.items.length would be wrong\n        // since we are removing values from the array\n        // the array is not shifting.\n        return this.total;\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    * @returns Boolean\n    */\n    isEmpty() {\n        return (this.total === 0);\n    }\n\n    /**\n    * Helper function to return an array\n    * of the LinkedList values.\n    *\n    * @return arr: Array\n    */\n    values(): any[] {\n        let arr = [];\n        if (this.getHead != null) {\n            let node = this.getHead();\n            for (let i = 0; i < this.size() && node != null; i++) {\n                arr.push(node);\n                // go to next node\n                node = node.next;\n            }\n        }\n        return arr;\n    }\n}\n","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Set.ts\");","/**\n * Set Data Structure\n * @class Set\n * @author Lee Boonstra\n *\n *      # What do we know about Sets?\n *      Set objects are collections of values.\n *      You can iterate through the elements of a set in insertion order.\n *      A value in the Set may only occur once; it is unique in the Set's collection.\n *      Because each value in the Set has to be unique, the value equality will be checked.\n *\n *      Since Set only contains distinct elements, it makes life much easier if we know in advance\n *      we want to avoid saving duplicate data to our structure.\n *      In Mathematics, it has concepts such as union, difference and intersection.\n *\n */\nexport class Set {\n    private items: Object;\n    private total: number;\n\n    constructor() {\n        this.items = {}; // note it's an object, so you can store only one key.\n        this.total = 0;\n    }\n\n    /**\n     * Check if the value exist. If not, add it to the set.\n     *\n     * @param  {string} element - String name value will be used as key and value\n     */\n    add(value: string) {\n        let isCreated = false;\n        if (!this.has(value)) {\n            this.items[this.total] = value;\n            isCreated = true;\n            this.total++;\n        }\n        return isCreated;\n    }\n\n    /**\n     * Remove value from the set\n     *\n     * @param {string} value - String name value will be used as key and value\n     */\n    delete(value: string) {\n        let isRemoved = false;\n        if (this.has(value)) {\n            delete this.items[value];\n            isRemoved = true;\n            this.total--;\n        }\n        return isRemoved;\n    }\n\n    /**\n     * Check if the value exist.\n     * Returns a boolean asserting whether an element is present with the given value in the Set object or not.\n     *\n     * @param {string} value - the value\n     * @return {boolean} isExisting - Boolean, returns true if value exists in Set.\n     */\n    has(value: string): Boolean {\n        let isExisting = false;\n        for (let key in this.items) {\n\n            if (this.items.hasOwnProperty(key)) {\n                 if (this.items[key] === value ) {\n                     if (parseInt(key) <= this.size()) {\n                        isExisting = true;\n                     }\n                 }\n            }\n        }\n        return isExisting;\n    }\n\n    /**\n     * Returns an array with all the keys of the Set\n     *\n     * @return {array} keys - Array with all the keys of the set\n     */\n    keys() {\n        let arr = [];\n        for (let item in this.items) {\n            arr.push(item)\n        }\n\n        return arr;\n    }\n\n    /**\n     * Returns an array with all the values of the Set\n     *\n     * @return {array} values - Array with all the values of the set\n     */\n    values() {\n        let arr = [];\n        for (let item in this.items) {\n            arr.push(this.items[item]);\n        }\n\n        return arr;\n    }\n\n    /**\n    * Removes all elements from the Set object.\n    */\n    clear(): void {\n        this.items = {};\n        this.total = 0;\n    }\n\n    /**\n    * Returns the number of values in the Set object.\n    *\n    * @return {number} total - Total amount of items in Set\n    */\n    size(): number {\n        return this.total;\n    }\n\n   /**\n    * Executes the callback function, for each item in the Set.\n    *\n    * @param {function} callback(key, val, set) - Callback function with 3 args key, value and set.\n    */\n    forEach(callback: Function) {\n        for (let key in this.items) {\n            callback(key, this.items[key], this.items);\n        }\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @returns {boolean} isEmpty - if the Stack is empty or not\n    */\n    isEmpty(): Boolean {\n        return (this.total === 0);\n    }\n\n    /**\n     * Given two sets, this returns a new set of elements from both of the given sets.\n     *\n     * @param {Set} otherSet - Another Set\n     * @return {Set} unionSet - Return a combined set.\n     */\n    union(otherSet: Set) {\n        let unionSet = new Set();\n\n        this.forEach(function(key: number, val: string, set: Set) {\n            unionSet.add(val)\n        });\n        otherSet.forEach(function(key: number, val: string, set: Set) {\n            unionSet.add(val)\n        });\n\n        return unionSet;\n    }\n\n    /**\n     * Given two sets, this returns a new set from elements that exist in both sets.\n     *\n     * @param {Set} otherSet - Another Set\n     * @return {Set} intersection - Return a intersection set.\n     */\n    intersection(otherSet: Set) {\n        let intersection = new Set();\n\n        this.forEach(function(key: number, val: string, set: Set) {\n            if (otherSet.has(val)) {\n                intersection.add(val);\n            }\n        });\n        return intersection;\n    }\n\n    /**\n     * Given two sets, this returns a new set with all the elements that\n     * exist in your set but not in the other set.\n     *\n     * @param {Set} otherSet - Another Set\n     * @return {Set} difference - Return a difference set.\n     */\n    difference(otherSet: Set) {\n        let difference = new Set();\n\n        this.forEach(function(key: number, val: string, set: Set) {\n            if (!otherSet.has(val)) {\n                difference.add(val);\n            }\n        });\n\n        return difference;\n    }\n\n    /**\n     * Given two sets, confirm with a boolean if this is a subset of another set.\n     *\n     * @param {Set} otherSet - Another Set\n     * @return {boolean} isSubset - Return boolean true if this is a subset.\n     */\n    isSubset(otherSet: Set) {\n        let isSubset = false;\n        let counter = 0;\n\n        // if this set is bigger than the other set, it can't be a subset\n        if (this.size() <= otherSet.size()) {\n            // loop through all items, and check if my values\n            // also exist in the other set.\n            // all values will need to exist.\n            this.forEach(function(key: number, val: string, set: Set) {\n                if (otherSet.has(val)) {\n                    counter++;\n                }\n            });\n        }\n\n        if (counter === this.size()) {\n            isSubset = true;\n        }\n\n        return isSubset;\n    }\n}\n","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Map.ts\");","/**\n * Map Data Structure\n * @class Map\n * @author Lee Boonstra\n *\n *      # What do we know about Map?\n *      Set objects are collections of key value pairs\n *      The key can be used to find a particular element.\n *      Other names are Dictionary, Symbol table or Associative Arrays\n *\n *      In computer science, maps are often used to store the refefence address of an object.\n *      For example, look in your Developer Tools, Memory tab and look at the Snapshots\n */\nexport class Map {\n    private items: Object;\n    private total: number;\n\n    constructor() {\n        this.items = {}; // note it's an object, so you can store only one key.\n        this.total = 0;\n    }\n\n    /**\n     * Check if the key exist. If not, add a key value pair\n     *\n     * @param  {string} key - String name key will be used as key and value\n     * @param  {string} value - String name value will be used as key and value\n     */\n    set(key: string, value: string) {\n        let isCreated = false;\n        if (!this.hasKey(key.toString())) {\n            this.items[key] = value;\n            isCreated = true;\n            this.total++;\n        }\n        return isCreated;\n    }\n\n    /**\n     * Remove value from the set\n     *\n     * @param  {string} key - String name key will be used as key and value\n     */\n    remove(key: string) {\n        let isRemoved = false;\n        if (this.hasKey(key.toString())) {\n            delete this.items[key];\n            isRemoved = true;\n            this.total--;\n        }\n        return isRemoved;\n    }\n\n    /**\n     * Check if the key exist.\n     * Returns a boolean asserting whether a key is present in the Map.\n     *\n     * @param {string} key - the key\n     * @return {boolean} isExisting - Boolean, returns true if value exists in Map.\n     */\n    hasKey(key: string): Boolean {\n        let isExisting = false;\n        if (this.items[key]) {\n            isExisting = true;\n        }\n        return isExisting;\n    }\n\n    /**\n     * Get the value from a specific key\n     *\n     * @param {string} key - the key\n     * @return {string} value - the value from the key\n     */\n    get(key: string): String {\n        return this.items[key.toString()];\n    }\n\n    /**\n     * Returns an array with all the keys of the Set\n     *\n     * @return {array} keys - Array with all the keys of the set\n     */\n    keys() {\n        let arr = [];\n        for (let item in this.items) {\n            arr.push(item)\n        }\n\n        return arr;\n    }\n\n    /**\n     * Returns an array with all the values of the Set\n     *\n     * @return {array} values - Array with all the values of the set\n     */\n    values() {\n        let arr = [];\n        for (let item in this.items) {\n            arr.push(this.items[item]);\n        }\n\n        return arr;\n    }\n\n    /**\n    * Removes all elements from the Set object.\n    */\n    clear(): void {\n        this.items = {};\n        this.total = 0;\n    }\n\n    /**\n    * Returns the number of values in the Set object.\n    *\n    * @return {number} total - Total amount of items in Set\n    */\n    size(): number {\n        return this.total;\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @returns {boolean} isEmpty - if the Stack is empty or not\n    */\n    isEmpty(): Boolean {\n        return (this.total === 0);\n    }\n\n\n   /**\n    * Executes the callback function, for each item in the Set.\n    *\n    * @param {function} callback(key, val, set) - Callback function with 3 args key, value and set.\n    */\n    forEach(callback: Function) {\n        for (let key in this.items) {\n            callback(key, this.items[key], this.items);\n        }\n    }\n}\n","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./HashTable.ts\");","import { SimpleDict } from './SimpleDict';\n\n/**\n * HashTable Data Structure\n * @class HashTable\n * @author Lee Boonstra\n *\n *      # What do we know about HashMap?\n *      Very similar to Maps/Associative Arrays, for storing\n *      key value pairs. You can find a stored value in the shortest\n *      time possible, O(1), rather than looping though each\n *      array value O(n) or using a sorted binary array\n *      or Tree O(log n).\n *\n *      Think about a student is assigned a student number\n *      that can be used to find information about him.\n *\n *      To make sure all key values in a HashTable are short\n *      as possible, and are integers to do fast lookup,\n *      we will need a hashing function.\n *      You will need to find a good hashing function, one\n *      that doesn't take too long to create a hash (when inserting/\n *      getting or removing). But you also don't want to make it\n *      to simple so you create collisions.\n *\n *      Although hash tables provide fast insertion, deletion, and retrieval,\n *      they perform poorly for operations that involve searching, such as finding the\n *      minimum and maximum values in a data set. For these operations, other data structures\n *      such as the binary search tree are more appropriate. Access and Deletion in worst case O(n)\n *\n *      ## Real world examples in Software Engineering?\n *      Browser vendors use hashtables a lot.\n *      But also when you use a database, you would set indexes to allow faster searching\n *\n */\nexport class HashTable {\n    private table: any[];\n    private total: number;\n    public bucketSize: number;\n    private probe: boolean;\n    private uniqueKeys: boolean;\n\n    /**\n     * @param {Object} opt - (optional)\n     * @param {boolean} opt.probe - enable probing default false\n     * @param {number} opt.bucketSize - if bucketSize set, create max HashTable buckets total. Less buckets is higher chance on collisions. Default 0, use good hashing function.\n     * @param {boolean} opt.uniqueKeys - skip duplicate key names so keys are unique default true\n     */\n    constructor(opt: any) {\n        this.table = [];\n        this.total = 0;\n        this.bucketSize = (opt.bucketSize || 0);\n        this.probe = (opt.probe || false);\n        this.uniqueKeys = (opt.uniqueKeys || true)\n    }\n\n    /**\n     * Check if the key exist. If not, add a key value pair\n     *\n     * @param  {string} key - String name key will be used as key and value\n     * @param  {string} value - String name value will be used as key and value\n     */\n    put(key: string, value: string) {\n        let isCreated = false;\n        let hash = this.hashCode(key);\n        if (!this.hasHash(hash)) {\n            this.table[hash] = new SimpleDict();\n            this.table[hash].set(key, value);\n            isCreated = true;\n            this.total++;\n        } else {\n            if (this.probe) {\n                let index = hash + 1;\n                while (this.table[index] !== undefined) {\n                    index++;\n                }\n                this.table[index] = new SimpleDict();\n                this.table[index].set(key, value);\n                isCreated = true;\n                this.total++;\n            } else {\n                // the hash already exists\n                if (this.uniqueKeys && this.table[hash].keys[0] === key) {\n                    // but the key is not unique\n                    // please skip duplicate\n                    console.error(key + ' already exists in HashTable, so skipped.');\n                } else {\n                    // now I want not a SimpleDict but an Array\n                    if (this.table[hash].constructor === SimpleDict) {\n                        let current = this.table[hash];\n                        this.table[hash] = []; // TODO or a LinkedList\n                        this.table[hash].push(current);\n                    }\n                    // its an array, add the new item\n                    let newItem = new SimpleDict();\n                    newItem.set(key, value);\n                    this.table[hash].push(newItem);\n                    isCreated = true;\n                    this.total++;\n                }\n            }\n        }\n\n        return isCreated;\n    }\n\n\n\n    /**\n     * Remove key value pair from the HashMap. When Collision with LinkedList is enabled, it will remove all occurences.\n     * When not probing best case O(1) worst case O(n).\n     *\n     * @param  {string} key - String name key will be used as key and value\n     */\n    remove(key: string) {\n        let isRemoved = false;\n        let hash = this.hashCode(key);\n        // when probing is enabled, and the table size doesn't match\n        // the bucket size, we will need to probe again to find\n        // the key back.\n        if (this.probe && (this.table.length !== this.bucketSize)) {\n            let index = hash;\n            // keep looping through you find the key\n            while (this.table[index].keys[0] !== key) {\n                index++;\n            }\n            this.table[index].remove(key);\n            isRemoved = true;\n            this.total--;\n        } else {\n            this.table[hash].remove(key);\n            isRemoved = true;\n            this.total--;\n        }\n\n        return isRemoved;\n    }\n\n    /**\n     * Check if the hash exist.\n     * Returns a boolean asserting whether a key is present in the Map.\n     *\n     * @param {number} hash - the hash\n     * @return {boolean} isExisting - Boolean, returns true if value exists in Map.\n     */\n    hasHash(hash: number): boolean {\n        let isExisting = false;\n        if (this.table[hash]) {\n            isExisting = true;\n        }\n        return isExisting;\n    }\n\n    /**\n     * Get the KeyValue Object pair from a specific key\n     * When not probing best case O(1) worst case O(n)\n     *\n     * @param {string} key - the key\n     * @return {Object | Array } return KeyValue Object or incase of LinkedList collision, an array with multiples.\n     */\n    get(key: string) {\n        let hash = this.hashCode(key);\n        let itemValue = undefined;\n\n        // when probing is enabled, and the table size doesn't match\n        // the bucket size, we will need to probe again to find\n        // the key back.\n        if (this.probe && (this.table.length !== this.bucketSize)) {\n            let index = hash;\n            // keep looping through you find the key\n            while (this.table[index].keys[0] !== key) {\n                index++;\n            }\n            itemValue = this.table[index].get(key);\n        } else {\n            if (this.table[hash].constructor === SimpleDict) {\n                itemValue = this.table[hash].get(key);\n            } else {\n                // there are multiples with this hash\n                // so we have to loop\n                let i = 0;\n                while (key !== this.table[hash][i].keys[0]) {\n                    i++;\n                }\n                itemValue = this.table[hash][i].get(key);\n            }\n        }\n\n        return itemValue;\n    }\n\n    /**\n    * Removes all elements from the Set object.\n    */\n    clear(): void {\n        this.table = [];\n        this.total = 0;\n    }\n\n    /**\n    * Returns the number of values in the Set object.\n    *\n    * @return {number} total - Total amount of items in Set\n    */\n    size(): number {\n        return this.total;\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @returns {boolean} isEmpty - if the Stack is empty or not\n    */\n    isEmpty(): Boolean {\n        return (this.total === 0);\n    }\n\n   /**\n    * Executes the callback function, for each item in the Set.\n    *\n    * @param {function} callback(key, val, set) - Callback function with 3 args key, value and set.\n    */\n    forEach(callback: Function) {\n        for (let key in this.table) {\n            callback(key, this.table[key], this.table);\n        }\n    }\n\n    /**\n     * Create a hash based on a key string\n     * The Hash-function takes a key and converts it to a number which will be the index at which to store it.\n     * I am computing a hash value by summing the ASCII value of each character of the string\n     * , multiplying the ASCII value by a multiplier 'code', which in this case, is an odd prime 37.\n     * And the reason to choose 37 being, by some empirical research, if we take over 50,000 English words\n     * will produce less than 7 collisions in each case, while creating a hasing function.\n     *\n     * @param {string} key - the key\n     */\n    hashCode(key: string): number {\n        let hash = 0;\n        const code = 37;\n        for (let i = 0; i < key.length; i++) {\n          hash += code * hash + key.charCodeAt(i);\n        }\n        if (this.bucketSize !== 0) {\n            hash = hash % this.bucketSize;\n        }\n        return hash;\n    }\n}\n","/**\n * Simple Associative Array / Dictionary\n * @class SimpleDict\n * @author: Lee Boonstra\n *\n * A simple Associative Array / Matrix\n * Slow O(n)\n*/\nexport class SimpleDict {\n    private keys: any[];\n    private values: any[];\n    private total: number;\n\n    constructor() {\n        this.keys = [];\n        this.values = [];\n        this.total = 0;\n    }\n\n    /**\n    * Set key value pair in SimpleDict\n    * O(1)\n    * @param {string} key - the key value\n    * @param {any} value - the value\n    * @returns {Boolean} true if succesful created\n    */\n    set(key: string, value: any): Boolean {\n        this.keys.push(key);\n        this.values.push(value);\n        this.total++;\n\n        return true;\n    }\n\n    /**\n    * Remove key value pair in SimpleDict\n    * O(n)\n    * @param {string} key - the key value\n    * @returns {Boolean} true if succesful removed\n    */\n    remove(key: string): Boolean {\n        let isRemoved = false;\n        for (let i = 0; i < this.keys.length; i++) {\n            if (this.keys[i] === key) {\n                delete this.keys[i];\n                delete this.values[i];\n                this.total--;\n                isRemoved = true;\n            }\n        }\n        return isRemoved;\n    }\n\n    /**\n    * Get value from SimpleDict\n    * O(n)\n    * @param {string} key - the key value\n    * @returns {any} value - the value that belongs to the key\n    */\n    get(key: string): any {\n        for (let i = 0; i < this.keys.length; i++) {\n            if (this.keys[i] === key) {\n                return this.values[i];\n            }\n        }\n    }\n\n   /**\n     * Check if the key exist.\n     * Returns a boolean asserting whether a key is present in the Map.\n     *\n     * @param {string} key - the key\n     * @return {boolean} isExisting - Boolean, returns true if value exists in Map.\n     */\n    hasKey(key: string): Boolean {\n        let isExisting = false;\n        if (this.keys[key]) {\n            isExisting = true;\n        }\n        return isExisting;\n    }\n\n    /**\n    * Get total size from SimpleDict\n    * O(1)\n    * @returns {number} total - the size of the SimpleDict\n    */\n    size(): number {\n        return this.total;\n    }\n\n    /**\n    * Checks if SimpleDict is empty\n    * O(1)\n    * @returns {boolean} isEmpty\n    */\n    isEmpty(): boolean {\n        return this.total === 0;\n    }\n\n    /**\n    * Clear the SimpleDict\n    * O(1)\n    * @returns {number} total - the size of the SimpleDict\n    */\n    clear(): number {\n        this.keys = [];\n        this.values = [];\n        this.total = 0;\n        return this.total;\n    }\n}","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Tree.ts\");","/**\n * TreeNode DataStructure\n * @class TreeNode\n * @author Lee Boonstra\n *\n */\nexport class TreeNode {\n    public key: number;\n    public left: TreeNode;\n    public right: TreeNode;\n\n    constructor(key: number, left: TreeNode = null, right: TreeNode = null) {\n        this.key = key;\n        this.left = left;\n        this.right = right\n    }\n}\n\n/**\n * Tree DataStructure\n * @class Tree\n * @author Lee Boonstra\n *\n *      # What do we know about Trees?\n *      A Tree is a non-linear data structure where data objects\n *      are organized in terms of hierarchical relationship.\n *      The structure is non-linear in the sense that,\n *      unlike simple array and linked list implementation,\n *      data in a tree is not organized linearly. Each data\n *      element is stored in a structure called a node.\n *\n *      Think about an organization chart of family tree.\n *\n *      ## BinarySearchTree (BST)\n *      A Node in a Tree can have multiple branches. In a BST\n *      the BST Node can only have 2 branches. One on the left,\n *      and one on the right. They are ordered. The left branch\n *      have values that are <= (lower or equal) than the parent node.\n *      The right branch has values that are => than the parent node.\n *      Therefore each lookup, insertion or deletion takes time\n *      in proporsional to the logarithm (log) of the number of the\n *      total items in the tree. (You can skip half of the tree).\n *      O(log n) instead of O(n) when sorting an array. However it is\n *      slower than the operations than a hashtable O(1).\n *\n *      ## Depth First Search (DFS)\n *\n *      ## Breadth First Search (BFS)\n *\n *      ## Real world examples in Software Engineering?\n *      DOM (Document Object Model)\n */\nexport class BinarySearchTree {\n    private root: TreeNode;\n\n    constructor() {\n        this.root = null;\n    }\n\n    // findMinNode()\n    // search(node, data)\n\n    /**\n     * Get the Root Node Value\n     * @returns {number | null} The Root Node Value\n     */\n    getRootNodeValue(): any {\n        let key = null;\n        if (this.root !== null) {\n            key = this.root.key;\n        }\n        return key;\n    }\n\n    /**\n     * Insert a node to a tree\n     * @param {number} key\n     */\n    insert(key: number) {\n        const node = this.root;\n        if (node == null) {\n            // this is the root node\n            // create a node based on this key\n            this.root = new TreeNode(key)\n            return;\n        } else {\n            // it's not the root node,\n            // so we will need to figure\n            // where to place this in the tree.\n            // let's use a recursive funciton\n            const searchTree = function(node: TreeNode): void {\n                // the key is smaller the parent node\n                if (key < node.key) {\n                    // when there are no nodes on the left side\n                    // we can start creating a node\n                    if (node.left == null) {\n                        // put it on the left side of the tree\n                        node.left = new TreeNode(key);\n                        return;\n                    } else if (node.left !== null) {\n                        // there are already nodes on the left\n                        // so we use a recursive function\n                        // passing in the node.left we just saw\n                        searchTree(node.left)\n                    }\n                } else if (key > node.key) {\n                    // when there are no nodes on the right side\n                    // we can start creating a node\n                    if (node.right == null) {\n                        // put it on the right side of the tree\n                        node.right = new TreeNode(key);\n                        return;\n                    } else if (node.right !== null) {\n                        // there are already nodes on the right\n                        // so we use a recursive function\n                        // passing in the node.right we just saw\n                        searchTree(node.right)\n                    } else {\n                        // the key must be equal. we won't add\n                        // it to the tree, we skip duplicates\n                        return null;\n                    }\n                }\n            }\n            // we will call the function\n            return searchTree(node);\n        }\n    }\n\n    /**\n     * This method returns the minimum value/key in the tree\n     */\n    min(): number {\n        let current = this.root;\n        // a while loop, continue searching\n        // till you are on the end of the left branch\n        while (current.left !== null && current.left !== undefined) {\n            current = current.left;\n        }\n        return current.key;\n    }\n\n    /**\n     * This method returns the maximum value/key in the tree\n     */\n    max(): number {\n        let current = this.root;\n        // a while loop, continue searching\n        // till you are on the end of the left branch\n        while (current.right != null) {\n            current = current.right;\n        }\n        return current.key;\n    }\n\n    /**\n     * This method searches for the key in the tree. It\n     * returns true if it exist and false if the node\n     * does not exist.\n     * @param {number} key - Key to search for\n     */\n    contains(key: number): boolean {\n        return (this.find(key) !== null)\n    }\n\n    /**\n     * This method searches for the key in the tree. It\n     * returns the TreeNode.\n     * @param {number} key - Key to search for\n     * @returns {TreeNode} - return node\n     */\n    find(key: number): TreeNode {\n        let current = this.root;\n        // when the current node is not null\n        while (current) {\n            // is it the current key?\n            if (key === current.key) {\n                // yep, found it\n                return current;\n            } else if (key < current.key) {\n                // value is lower than the parent\n                // let's look left\n                current = current.left;\n            } else {\n                // value is higher than the parent\n                // let's look right\n                current = current.right;\n            }\n            // haven't found it so continue looking\n        }\n        // we didn't find it, the key might be not in the tree\n        return null;\n    }\n\n    /**\n     * Removes a node in a tree.\n     * @param {number} data\n     */\n    remove(key: number) {\n        const removeNode = function(node: TreeNode, key: number): TreeNode {\n            if (node == null) {\n                // we have an empty tree\n                return null;\n            }\n            // can we find the data in the tree\n            if (key === node.key) {\n                // when the value is in the tree,\n                // there are 4 options:\n\n                // 1)\n                // node has no children, means its a leaf node\n                // we can just delete that node by setting\n                // the data of that node to null. (removing pointers)\n                if (node.left === null && node.right === null) {\n                    return null;\n                }\n\n                // 2)\n                // node has no left child\n                // we will replace pointers\n                // the parent node will get\n                // the right node from the to be deleted node\n                // as a new pointer\n                if (node.left === null) {\n                    return node.right;\n                }\n\n                // 3)\n                // node has no right child\n                // we will replace pointers\n                // the parent node will get\n                // the left node from the to be deleted node\n                // as a new pointer\n                if (node.right === null) {\n                    return node.left;\n                }\n\n                // 4)\n                // node has both children\n                // this is a bit more complicated\n                // cause you can't replace pointers\n                // of one, cause what would happen to the\n                // other child.\n\n                // we will first look to the right node\n                let tempNode = node.right;\n                // and find the min in the branch by\n                // looking all the way left\n                while (tempNode.left !== null) {\n                    tempNode = tempNode.left;\n                };\n                // the node that will need to be deleted\n                // gets the node data from the tempNode\n                // the one from all the way left\n                node.key = tempNode.key;\n\n                // and we will need to go back in this function\n                // again to make sure we re-link all the other\n                // pointers\n                node.right = removeNode(node.right, tempNode.key);\n                return node;\n            } else if (key < node.key) {\n                node.left = removeNode(node.left, key);\n                return node;\n            } else {\n                node.right = removeNode(node.right, key);\n                return node;\n            }\n        }\n        // call the recursive function, start with the root\n        this.root = removeNode(this.root, key);\n    }\n\n\n    /**\n     * Get the Tree Min Height\n     * Recursive Function\n     * @param {TreeNode} node - (default) rootNode\n     * @returns {number} minHeight - of the tree\n     */\n    getMinHeight(node = this.root): number {\n        if (node == null) {\n            // every time when you reach the leaf node\n            // return -1, so it's a number;\n            return -1;\n        }\n\n        // when node is not null, so it's not a leaf\n        // call this function again, passing in the\n        // previous node, that way you are walking\n        // through all the lefts, and all the rights.\n        let leftBranch = this.getMinHeight(node.left);\n        let rightBranch = this.getMinHeight(node.right);\n\n        // when the left branche is smaller\n        // start walking left, otherwise\n        // walk through the right branche\n        // and start counting (+1) till the end (null)\n\n        // the branch that's the smallest\n        // will contain the min height\n        if (leftBranch < rightBranch) {\n            return leftBranch + 1;\n        } else {\n            return rightBranch + 1;\n        }\n    }\n\n    /**\n     * Get the Tree Max Height\n     * @param {TreeNode} node - (default) rootNode\n     * @returns {number} maxHeight - of the tree\n     */\n    getMaxHeight(node = this.root): number {\n        if (node == null) {\n            // every time when you reach the leaf node\n            // return -1, so it's a number;\n            return -1;\n        }\n\n        // when node is not null, so it's not a leaf\n        // call this function again, passing in the\n        // previous node, that way you are walking\n        // through all the lefts, and all the rights.\n        let leftBranch = this.getMaxHeight(node.left);\n        let rightBranch = this.getMaxHeight(node.right);\n\n        // when the left branche is bigger\n        // start walking left, otherwise\n        // walk through the right branche\n        // and start counting (+1) till the end (null)\n\n        // the branch that's the biggest\n        // will contain the max height\n        if (leftBranch > rightBranch) {\n            return leftBranch + 1;\n        } else {\n            return rightBranch + 1;\n        }\n    }\n\n    /**\n     * Is Tree Balanced? A tree is balanced when the branches are equal or have 1 level difference.\n     * @returns {boolean} if the Tree is Balanced\n     */\n    isBalanced(): boolean {\n        return(this.getMinHeight()\n            >= this.getMaxHeight() - 1);\n    }\n\n    /**\n     * Traverse the tree\n     * @param {object} opt\n     * @param {string} opt.method - inOrder | preOrder | postOrder | levelOrder (default inOrder); \n     * @returns {array} - sorted array\n     */\n    traverse(opt: any): any {\n        let array = new Array();\n        let method = \"\";\n        if (opt.method) {\n            method = opt.method.toLowerCase();\n        }\n        console.log(method);\n        switch (method) {\n            case \"inorder\":\n                array = this.inorder();\n                break;\n            case \"preorder\":\n                array = this.preorder();\n                break;\n            case \"postorder\":\n                array = this.postorder();\n                break;\n            case \"levelorder\":\n                array = this.levelorder();\n                break;\n            default:\n                array = this.inorder();\n        }\n\n        return array;\n    }\n\n    /**\n     * Traverses nodes of a tree with DFS\n     * @returns {array} - return an inorder array\n     */\n    inorder(): any[] {\n        if (this.root == null) {\n            // check if there's a BST\n            // and if there are values\n            // in it\n            console.log(\"root = null\");\n            return null;\n        } else {\n            let result = new Array();\n            // recursive function\n            function traverseInOrder(node: TreeNode) {\n                // we start from the root node.\n\n                // if the current node has a node.left\n                // then call this function\n                // again but pass in the left node\n                // else ignore\n                // if (node.left) console.log(\"execute if node \" + node.key + \" has a left: \" + node.left.key);\n                node.left && traverseInOrder(node.left);\n\n                // and then add the value to the array\n                // so for everytime you called the \n                // function, you still will add values\n                // to the array\n                // console.log(\"push in array \" + node.key);\n                result.push(node.key);\n\n                // next, check if the current node has\n                // a right node. else ignore\n                // in case not, go up\n                // pass that node to the array\n\n                // if node.right does exist call this function\n                // again but pass in the right node\n                // if (node.right) console.log(\"execute if node \" + node.key + \" has a right: \" + node.right.key);\n                node.right && traverseInOrder(node.right);\n            }\n            traverseInOrder(this.root);\n            return result;\n        }\n    }\n\n    /**\n     * Traverses nodes of a tree with BFS\n     * @returns {array} - return an preorder array\n     */\n    preorder(): any[] {\n        if (this.root == null) {\n            // check if there's a BST\n            // and if there are values\n            // in it\n            return null;\n        } else {\n            let result = new Array();\n            // recursive function\n            function traversePreOrder(node: TreeNode) {\n                // add the key in the results array\n                result.push(node.key);\n                // if node.left exist call this function\n                // again but pass in the left node\n                node.left && traversePreOrder(node.left);\n                // if node.right exist call this function\n                // again but pass in the right node\n                node.right && traversePreOrder(node.right);\n            }\n            traversePreOrder(this.root);\n            return result;\n        }\n    }\n\n    /**\n     * Traverses nodes of a tree with BFS\n     * @returns {array} - return an postorder array\n     */\n    postorder(): any[] {\n        if (this.root == null) {\n            // check if there's a BST\n            // and if there are values\n            // in it\n            return null;\n        } else {\n            let result = new Array();\n            // recursive function\n            function traversePostOrder(node: TreeNode) {\n                // if node.left exist call this function\n                // again but pass in the left node\n                node.left && traversePostOrder(node.left);\n                // if node.right exist call this function\n                // again but pass in the right node\n                node.right && traversePostOrder(node.right);\n                // add the key in the results array\n                result.push(node.key);\n            }\n            traversePostOrder(this.root);\n            return result;\n        }\n    }\n\n    /**\n     * Traverses nodes for each level\n     * @returns {array} - return an level order array\n     */\n    levelorder(): any {\n        let results = [];\n        let queue = [];\n        if (this.root != null) {\n            queue.push(this.root);\n            // now we will loop\n            // as long as there are\n            // items in the queue\n            while (queue.length > 0) {\n                let node = queue.shift();\n                // takes the first element in the\n                // array and remove that element\n                // so we will start with the rootnode\n                // in the queue. and after shifting\n                // it's not in the queue anymore\n\n                // we can put the key in the results array\n                results.push(node.key);\n\n                if (node.left != null) {\n                    // console.log(node.key + \" has a left node: \" + node.left.key)\n                    // when there is a left node\n                    // we can put it to the queue\n                    // so the while loop won't stop\n                    queue.push(node.left);\n                }\n                if (node.right != null) {\n                    // console.log(node.key + \" has a right node: \" + node.right.key)\n            \n                    // when there is a right node\n                    // we can put it to the queue\n                    // so the while loop won't stop\n                    queue.push(node.right);\n                }\n\n                // when there are items in the queue,\n                // we can start adding it to the results\n                // array, and start checking for the next\n                // level.\n            }\n            return results;\n        } else {\n            return null;\n        }\n    }\n}","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Graph.ts\");","import { LinkedList } from '../datastructures/LinkedList';\nimport { SimpleDict } from '../datastructures/SimpleDict';\n\n/**\n * Each node object  / Vertex\n * @class GraphNode\n * @author Lee Boonstra\n * @param {string} id - string with the node id\n */\nexport class GraphNode {\n    public id: string;\n    public adjacents: Array<string>;\n\n    constructor(id: string) {\n        this.id = id;\n        this.adjacents = new Array();\n    }\n}\n\n/**\n * Create a Graph\n * @class Graph\n * @author Lee Boonstra\n * @param {array} nodeIds - An array with all the string ids to be created\n * @param {array} matrix - A 2 dimensional array (matrix), used as an adjacency list\n */\nexport class Graph {\n    private vertices: Object;\n    private nodeIds: any[];\n    public matrix: any[];\n    private counter: number;\n\n    constructor (nodeIds: Array<string>, matrix: any) {\n        this.matrix = matrix;\n        this.nodeIds = nodeIds;\n        this.vertices = {};\n        this.counter = 0;\n\n        // the matrix should have for each row a vertex\n        if (nodeIds.length !== this.matrix.length) {\n            throw \"The size of the matrix doesn't contain the total of vertices\";\n        }\n\n        // loop through the array rows\n        for (let i = 0; i < matrix.length; i++) {\n            // create a vertex node, for each row in the matrix\n            let node = new GraphNode(this.nodeIds[i]);\n\n            // loop through all the adjacents\n            for (let j = 0; j < this.matrix[i].length; j++) {\n                // Add the adjacent, when it's marked\n                // as one in the matrix.\n                if (matrix[i][j] === 1) {\n                    node.adjacents.push(this.nodeIds[j]);\n                }\n            }\n\n            // each vertex gets a row in the vertices array\n            this.vertices[node.id] = node;\n        }\n\n        console.log(this.vertices);\n    }\n\n\n\n    /**\n     * Get the Node that belongs to a particular node id.\n     * @param {number} nodeId - Node id to look for\n     * @returns {Node} node - The matching node\n     */\n    getNode(nodeId: string): GraphNode {\n        return this.vertices[nodeId];\n    }\n\n    addNode() {\n\n\n\n\n    }\n\n    addEdge() {\n\n    }\n\n    /**\n     * Check if Path exist via Depth First Search\n     * Go deep into nodes, before exploring other nodes.\n     * Recursive Function\n     * @param {string} startId - The Node Id to start searching from\n     * @param {string} destinationId = The Node Id that needs to be found\n     * @returns {boolean} pathExists = return true if a path was found\n     */\n    public hasPathDfs(startId: string, destinationId: string): boolean {\n        let pathExists = false;\n        let source = this.getNode(startId);\n        let destination = this.getNode(destinationId);\n        let visited = new SimpleDict();\n\n        this._hasPathDfs(source, destination, visited);\n\n        return pathExists;\n    }\n\n\n    /**\n     * Check if Path exist via Depth First Search\n     * Go deep into nodes, before exploring other nodes.\n     * Recursive Function\n     * @param {number} startId - The Node Id to start searching from\n     * @param {number} destinationId = The Node Id that needs to be found\n     * @returns {boolean} pathExists = return true if a path was found\n     */\n    private _hasPathDfs(source: GraphNode, destination: GraphNode, visited: SimpleDict): boolean {\n        let pathExists = false;\n        this.counter++;\n        if (this.counter === 10) return false;\n\n        console.log(source);\n        console.log(visited);\n        console.log(visited.hasKey(source.id));\n        if (visited.hasKey(source.id)) {\n            // you have visited the node before\n            // this is also the part thats would\n            // stop the recursive function\n            pathExists = false;\n        } else {\n            visited.set(source.id, true);\n        }\n\n        // the node you are looking for\n        // is the same as the destination\n        if (source === destination) {\n            pathExists = true;\n        }\n\n        // now look into its adjacents\n        for (let index in source.adjacents) {\n            let node = this.getNode(this.nodeIds[index]);\n            // recursive, keep looking in its neighbors\n            this._hasPathDfs(node, destination, visited);\n        }\n\n        return pathExists;\n    }\n\n    /**\n     * Check if Path exist via Breath First Search\n     * Go wide, and first check all neighbor nodes. (adjacents) before going deep.\n     * Need a Queue / LinkedList for this\n     */\n    hasPathBfs(startId: number, destinationId: number): boolean {\n        let pathExists = false;\n\n        // TODO\n\n        return pathExists;\n    }\n\n}\n"],"sourceRoot":""}