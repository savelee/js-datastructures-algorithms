{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../node_modules/webpack/buildin/global.js-exposed","webpack:///./ts/datastructures/SimpleDict.ts-exposed","webpack:///./ts/datastructures/Queue.ts-exposed","webpack:///./index.ts-exposed","webpack:///../node_modules/webpack/buildin/global.js","webpack:///./index.ts","webpack:///./ts/datastructures/Stack.ts-exposed","webpack:///./ts/datastructures/Stack.ts","webpack:///./ts/datastructures/Queue.ts","webpack:///./ts/datastructures/LinkedList.ts-exposed","webpack:///./ts/datastructures/LinkedList.ts","webpack:///./ts/datastructures/Set.ts-exposed","webpack:///./ts/datastructures/Set.ts","webpack:///./ts/datastructures/Map.ts-exposed","webpack:///./ts/datastructures/Map.ts","webpack:///./ts/datastructures/HashTable.ts-exposed","webpack:///./ts/datastructures/HashTable.ts","webpack:///./ts/datastructures/SimpleDict.ts","webpack:///./ts/datastructures/Tree.ts-exposed","webpack:///./ts/datastructures/Tree.ts","webpack:///./ts/datastructures/Graph.ts-exposed","webpack:///./ts/datastructures/Graph.ts","webpack:///./ts/algorithms/Sorters.ts-exposed","webpack:///./ts/algorithms/Sorters.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","global","g","this","Function","e","window","Stack_1","Queue_1","LinkedList_1","Set_1","Map_1","HashTable_1","Tree_1","Graph_1","SimpleDict_1","Sorters_1","Stack","Queue","LinkedList","Set","Map","HashTable","BinarySearchTree","Graph","SimpleDict","Sorters","[object Object]","items","total","item","undefined","isEmpty","count","length","Node","node","next","head","last_node","getHead","setHead","index","isInserted","size","newNode","previous","getNodeAt","current","console","log","values","indexOf","removeAt","isRemoved","error","arr","push","isCreated","has","isExisting","parseInt","callback","otherSet","unionSet","forEach","val","set","add","intersection","difference","isSubset","counter","hasKey","toString","opt","table","bucketSize","probe","uniqueKeys","hash","hashCode","hasHash","keys","constructor","newItem","remove","itemValue","charCodeAt","TreeNode","left","right","root","searchTree","find","removeNode","tempNode","leftBranch","getMinHeight","rightBranch","getMaxHeight","array","Array","method","toLowerCase","inorder","preorder","postorder","levelorder","result","traverseInOrder","traversePreOrder","traversePostOrder","results","queue","shift","GraphNode","id","adjacents","nodeIds","matrix","vertices","j","nodeId","startId","destinationId","pathExists","source","getNode","destination","visited","_hasPathDfs","_hasPathBfs","neighbor"],"mappings":"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","file":"app.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","module.exports = global[\"Library\"] = require(\"-!./global.js\");","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./SimpleDict.ts\");","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Queue.ts\");","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./index.ts\");","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import { Stack } from \"./ts/datastructures/Stack\";\nimport { Queue } from \"./ts/datastructures/Queue\";\nimport { LinkedList } from \"./ts/datastructures/LinkedList\";\nimport { Set } from \"./ts/datastructures/Set\";\nimport { Map } from \"./ts/datastructures/Map\";\nimport { HashTable } from \"./ts/datastructures/HashTable\";\nimport { BinarySearchTree } from \"./ts/datastructures/Tree\";\nimport { Graph } from \"./ts/datastructures/Graph\";\nimport { SimpleDict } from \"./ts/datastructures/SimpleDict\";\nimport { Sorters } from \"./ts/algorithms/Sorters\";\n\nmodule.exports =  { Stack, Queue, LinkedList, Set, Map,\n    HashTable, BinarySearchTree, Graph, SimpleDict,\n    Sorters}\n","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Stack.ts\");","/**\n * Stack Data Structure\n * @class Stack\n * @author Lee Boonstra\n *\n *      # What do we know about Stacks?\n *      It's a sequential data structure with LIFO. Last In - First Out principle.\n *      (and FILO First in - Last Out)\n *      Compare this to a deck of cards. The last card on top, is the first\n *      card to be removed from the pile. The base card, will be last.\n *\n *      ## Real world examples in Software Engineering?\n *      The browser history. Clipboard history.\n *      In the Sencha Ext JS framework there was a card layout / animation.\n *      The deck of cards in Hearthstone.\n */\nexport class Stack {\n    private items: any[];\n    private total: number;\n\n    constructor() {\n        // Based on an Array\n        this.items = [];\n        // Set the total to 0;\n        this.total = 0;\n    }\n\n    /**\n     * Add a new item to the top of the stack.\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @param {any} item - item\n     */\n    push(item: any) {\n        // this.items.push(item);\n        // We can only add one at a time\n        this.items[this.total] = item;\n        this.total++;\n    }\n\n    /**\n     * Pops / Removes the top item from the stack.\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @return {any} item - removed item\n     */\n    pop(): any {\n        let item = undefined;\n        if (!this.isEmpty()) {\n            this.total--;\n            // return this.items.pop();\n            // manual remove\n            item = this.items[this.total];\n            delete this.items[this.total];\n        }\n        return item;\n    }\n\n    /**\n    * Return the top item from the stack.\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return {item} item - top item\n    */\n    peek(): any {\n        if (this.isEmpty()) return undefined;\n\n        let i = this.total - 1;\n        return this.items[i];\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @returns {boolean} isEmpty - if the Stack is empty or not\n    */\n    isEmpty(): Boolean {\n        return (this.total === 0);\n    }\n\n    /**\n    * Removes all the items from the Stack\n    * Take O(1) time. We do not run any loop in any of these operations.\n    */\n    clear() {\n        if (!this.isEmpty()) {\n            this.items = [];\n            this.total = 0;\n        }\n    }\n\n    /**\n    * Return the total number of items from the stack\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return {number} size - total length of Stack\n    */\n    size(): number {\n        // Note: in this example this.items.length would be wrong\n        // since we are removing values from the array\n        // the array is not shifting.\n        return this.total;\n    }\n\n    /**\n     * Print stack\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @return {array} - array with items\n     */\n    values(): any[] {\n        return this.items;\n    }\n}\n","/**\n * Queue Data Structure\n * @class Queue\n * @author Lee Boonstra\n *\n *      # What do we know about Queues?\n *      It's a sequential data structure with FIFO. First In - First Out principle.\n *      (and LILO Last in - Last Out)\n *      Compare this to the line in at the bakery. First person in the line, takes\n *      a ticket from the counting machine, and will be served first, based on the counter.\n *\n *      ## Real world examples in Software Engineering?\n *      Printer Queue.\n */\nexport class Queue {\n    private items: any[];\n    private total: number; // total items in the queue\n    private count: number; // item count who will be served first\n\n    constructor() {\n        // Based on an Array\n        this.items = [];\n        // A queue needs at least one person.\n        this.total = 1;\n        // Set the count to 0\n        // Compared to Stacks, this is what makes this class different!\n        this.count = 0;\n    }\n\n    /**\n     * Add a new item to the back of the queue.\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @param item any\n     */\n    add(item: any) {\n        this.items[this.items.length] = item;\n        this.total++;\n    }\n\n    /**\n     * Retrieves and removes the head of this queue.\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @return removed item\n     */\n    remove(): any {\n        let item = undefined;\n        if (!this.isEmpty()) {\n            // which item will be first in the queue\n            // is is based on the counting system\n            item = this.items[this.count];\n            // remove this item from the queue\n            delete this.items[this.count];\n            // the queue size is now shorter\n            this.total--;\n            // but the number counter goes up\n            this.count++;\n        }\n        return item;\n    }\n\n    /**\n    * Return the the head of the queue\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return removed item\n    */\n    peek(): any {\n        if (this.isEmpty()) return undefined;\n\n        return this.items[this.count];\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return Boolean\n    */\n    isEmpty(): Boolean {\n        return (this.total <= 1);\n    }\n\n    /**\n    * Removes all the items from the Stack\n    * Take O(1) time. We do not run any loop in any of these operations.\n    */\n    clear() {\n        if (!this.isEmpty()) {\n            this.items = [];\n            this.total = 1;\n            this.count = 0; // reset counter\n        }\n    }\n\n    /**\n    * Return the total number of items from the stack\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return number\n    */\n    size(): number {\n        // Note: in this example this.items.length would be wrong\n        // since we are removing values from the array\n        // the array is not shifting.\n\n        return this.total - 1;\n    }\n\n    /**\n     * Print stack\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @return items\n     */\n    values(): any[] {\n        return this.items;\n    }\n}\n","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./LinkedList.ts\");","/**\n * LinkedList Data Structure\n * @class Node\n * @author Lee Boonstra\n *\n *      # What do we know about LinkedLists?\n *\n *      It's a sequential data structure and has\n *      similarities with an Array (also called a List).\n *      In other languages, an Array has a predefined\n *      size. Inserting and Removing items can be\n *      expensive. Because elements needs to be shifted\n *      over. A LinkedList is a dynamic data structure. We\n *      can add and remove items from it and it will grow\n *      when required. Elements are not placed\n *      contiguously in memory. Each node stores the\n *      element itself and also a reference (pointer\n *      link). Think about this as christmas lights. In\n *      order to find a broken light, you have to visit\n *      each light from beginning (head) to end (tail).\n *\n *      ## Real world examples in Software Engineering?\n *\n *      History and Subversioning? A trial of revisions\n *      and you can add branches?\n */\nexport class Node {\n    public node: Node;\n    public next: Node; // pointer\n    constructor(item: any) {\n        this.node = item;\n        this.next = undefined;\n    }\n}\n\n/**\n * LinkedList Data Structure\n * @class LinkedList\n * @author Lee Boonstra\n *\n *      # What do we know about LinkedLists?\n *\n *      It's a sequential data structure and has\n *      similarities with an Array (also called a List).\n *      In other languages, an Array has a predefined\n *      size. Inserting and Removing items can be\n *      expensive. Because elements needs to be shifted\n *      over. A LinkedList is a dynamic data structure. We\n *      can add and remove items from it and it will grow\n *      when required. Elements are not placed\n *      contiguously in memory. Each node stores the\n *      element itself and also a reference (pointer\n *      link). Think about this as christmas lights. In\n *      order to find a broken light, you have to visit\n *      each light from beginning (head) to end (tail).\n *\n *      ## Real world examples in Software Engineering?\n *\n *      History and Subversioning? A trial of revisions\n *      and you can add branches?\n */\nexport class LinkedList {\n    private head: Node;\n    private total: number;\n\n    constructor() {\n        // when you create a LinkedList the head is empty\n        this.head = null;\n        this.total = 0;\n    }\n\n    /**\n    * Add new item to the end of the LinkedList\n    * Take O(n) time. Loop to figure out the last node.\n    *\n    * @param item: any\n    * @return isAdded Boolean\n    */\n    push(item: any): Boolean {\n        const node = new Node(item);\n        let last_node;\n\n        if (this.getHead() == null) {\n            // the list is empty, adding a new item\n            this.setHead(node);\n        } else {\n            // the list is not empty, append items\n            last_node = this.getHead();\n            // start from the head, keep iterating, till\n            // you find the last node (tail, which is the node with next = null)\n            while (last_node.next != null) {\n                last_node = last_node.next;\n            }\n\n            last_node.next = node;\n        }\n        this.total++;\n\n        return true;\n    }\n\n    /**\n    * Insert a new item at a specified position in the\n    * LinkedList.\n    * Take O(n) time. To find the previous node, we will need to loop.\n    *\n    * @param index: number\n    * @param item: any\n    * @return isInserted Boolean\n    */\n    insert(index: number, item: any): Boolean {\n        let isInserted = false;\n        if (index >= 0 && index <= this.size()) {\n            const newNode = new Node(item);\n\n            if (index === 0) {\n                // This will be the head node.\n                this.setHead(newNode);\n                // update all the references\n            } else {\n                // iterate through all the nodes before the to be added node.\n                // and set a pointer to the next node\n                let previous = this.getNodeAt(index - 1);\n                let current = previous.next;\n                newNode.next = current;\n                previous.next = newNode;\n            }\n\n            console.log(this.values());\n            this.total++;\n        } else {\n            isInserted = false;\n        }\n\n        return isInserted;\n    }\n\n   /**\n    * Get the very first item in the LinkedList\n    *\n    * @return head: Node\n    */\n    getHead(): Node {\n        return this.head;\n    }\n\n  /**\n    * Set the very first item in the LinkedList\n    *\n    * @param node: Node\n    */\n    setHead(node: Node): void {\n        this.head = node;\n    }\n\n   /**\n    * Get the index of a specific node in the\n    * LinkedList. Returns -1 if it doesn't exist.\n    * Take O(n) time. To find the item, you will need to visit all the nodes\n    *\n    * @param node\n    * @return index: number | -1\n    */\n    indexOf(item: any): number {\n        let index = -1;\n        let node = this.getHead();\n        // keep iterating through the total amount of nodes\n        // till you reach the end (node = null and total)\n        for (let i = 0; i < this.total && node != null; i++) {\n            // this should be the one\n            if (item === node.node) {\n                index = i;\n            }\n            node = node.next;\n        }\n\n        return index;\n    }\n\n    /**\n    * Get the item of a specific index in the\n    * LinkedList. Returns undefined if it doesn't exist.\n    * Take O(n) time. To find the item, you will need to visit all the nodes\n    *\n    * @param index: number\n    * @return node: Node | undefined\n    */\n    getNodeAt(index: number): Node {\n        let node = undefined;\n\n        if (index >= 0 && index <= this.total) {\n            node = this.getHead();\n\n            // keep iterating till you reach the index\n            for (let i = 0; i < index && node != null; i++) {\n                node = node.next;\n            }\n\n        }\n\n        return node;\n    }\n\n    /**\n     * Removes an item from the LinkedList.\n     * Take O(n) time. To find the item to be removed, you will need to visit all the nodes\n     *\n     * @param item: any\n     * @return isRemoved Boolean\n     */\n    remove(item: any): Boolean {\n        let index = this.indexOf(item);\n        let result = this.removeAt(index);\n\n        return result;\n    }\n\n    /**\n     * Removes item from a specified index in the LinkedList.\n     * Take O(n) time. To find the item to be removed, you will need to visit all the nodes.\n     *\n     * @param position: number\n     * @return isRemoved Boolean\n     */\n    removeAt(index: number): Boolean {\n        let isRemoved = false;\n        if (index < 0) {\n            // throw \"Can't remove, because item is not in the LinkedList.\";\n            console.error(\"Can't remove, because item is not in the LinkedList.\");\n        } else {\n            let current = this.getHead();\n\n            if (index === 0 ) {\n                // this is the very first node\n                // remove (and update all positions)\n                this.setHead(current.next);\n            } else {\n                // iterate through all the nodes before the to be removed node.\n                // and set a pointer to the next node\n                let previous;\n                for (let i = 0; i < index; i++) {\n                    // temp store the one before\n                    previous = current;\n                    // go to the next node\n                    current = current.next;\n                }\n                // now let remove the reference of the previous node\n                // to skip it, and go to the next one.\n                previous.next = current.next;\n            }\n\n            this.total--;\n            isRemoved = true;\n        }\n        return isRemoved;\n    }\n\n    /**\n    * Return the total number of items from the stack\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return number\n    */\n    size() {\n        // Note: in this example this.items.length would be wrong\n        // since we are removing values from the array\n        // the array is not shifting.\n        return this.total;\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    * @returns Boolean\n    */\n    isEmpty() {\n        return (this.total === 0);\n    }\n\n    /**\n    * Helper function to return an array\n    * of the LinkedList values.\n    *\n    * @return arr: Array\n    */\n    values(): any[] {\n        let arr = [];\n        if (this.getHead != null) {\n            let node = this.getHead();\n            for (let i = 0; i < this.size() && node != null; i++) {\n                arr.push(node);\n                // go to next node\n                node = node.next;\n            }\n        }\n        return arr;\n    }\n}\n","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Set.ts\");","/**\n * Set Data Structure\n * @class Set\n * @author Lee Boonstra\n *\n *      # What do we know about Sets?\n *      Set objects are collections of values.\n *      You can iterate through the elements of a set in insertion order.\n *      A value in the Set may only occur once; it is unique in the Set's collection.\n *      Because each value in the Set has to be unique, the value equality will be checked.\n *\n *      Since Set only contains distinct elements, it makes life much easier if we know in advance\n *      we want to avoid saving duplicate data to our structure.\n *      In Mathematics, it has concepts such as union, difference and intersection.\n *\n */\nexport class Set {\n    private items: Object;\n    private total: number;\n\n    constructor() {\n        this.items = {}; // note it's an object, so you can store only one key.\n        this.total = 0;\n    }\n\n    /**\n     * Check if the value exist. If not, add it to the set.\n     *\n     * @param  {string} element - String name value will be used as key and value\n     */\n    add(value: string) {\n        let isCreated = false;\n        if (!this.has(value)) {\n            this.items[this.total] = value;\n            isCreated = true;\n            this.total++;\n        }\n        return isCreated;\n    }\n\n    /**\n     * Remove value from the set\n     *\n     * @param {string} value - String name value will be used as key and value\n     */\n    delete(value: string) {\n        let isRemoved = false;\n        if (this.has(value)) {\n            delete this.items[value];\n            isRemoved = true;\n            this.total--;\n        }\n        return isRemoved;\n    }\n\n    /**\n     * Check if the value exist.\n     * Returns a boolean asserting whether an element is present with the given value in the Set object or not.\n     *\n     * @param {string} value - the value\n     * @return {boolean} isExisting - Boolean, returns true if value exists in Set.\n     */\n    has(value: string): Boolean {\n        let isExisting = false;\n        for (let key in this.items) {\n\n            if (this.items.hasOwnProperty(key)) {\n                 if (this.items[key] === value ) {\n                     if (parseInt(key) <= this.size()) {\n                        isExisting = true;\n                     }\n                 }\n            }\n        }\n        return isExisting;\n    }\n\n    /**\n     * Returns an array with all the keys of the Set\n     *\n     * @return {array} keys - Array with all the keys of the set\n     */\n    keys() {\n        let arr = [];\n        for (let item in this.items) {\n            arr.push(item)\n        }\n\n        return arr;\n    }\n\n    /**\n     * Returns an array with all the values of the Set\n     *\n     * @return {array} values - Array with all the values of the set\n     */\n    values() {\n        let arr = [];\n        for (let item in this.items) {\n            arr.push(this.items[item]);\n        }\n\n        return arr;\n    }\n\n    /**\n    * Removes all elements from the Set object.\n    */\n    clear(): void {\n        this.items = {};\n        this.total = 0;\n    }\n\n    /**\n    * Returns the number of values in the Set object.\n    *\n    * @return {number} total - Total amount of items in Set\n    */\n    size(): number {\n        return this.total;\n    }\n\n   /**\n    * Executes the callback function, for each item in the Set.\n    *\n    * @param {function} callback(key, val, set) - Callback function with 3 args key, value and set.\n    */\n    forEach(callback: Function) {\n        for (let key in this.items) {\n            callback(key, this.items[key], this.items);\n        }\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @returns {boolean} isEmpty - if the Stack is empty or not\n    */\n    isEmpty(): Boolean {\n        return (this.total === 0);\n    }\n\n    /**\n     * Given two sets, this returns a new set of elements from both of the given sets.\n     *\n     * @param {Set} otherSet - Another Set\n     * @return {Set} unionSet - Return a combined set.\n     */\n    union(otherSet: Set) {\n        let unionSet = new Set();\n\n        this.forEach(function(key: number, val: string, set: Set) {\n            unionSet.add(val)\n        });\n        otherSet.forEach(function(key: number, val: string, set: Set) {\n            unionSet.add(val)\n        });\n\n        return unionSet;\n    }\n\n    /**\n     * Given two sets, this returns a new set from elements that exist in both sets.\n     *\n     * @param {Set} otherSet - Another Set\n     * @return {Set} intersection - Return a intersection set.\n     */\n    intersection(otherSet: Set) {\n        let intersection = new Set();\n\n        this.forEach(function(key: number, val: string, set: Set) {\n            if (otherSet.has(val)) {\n                intersection.add(val);\n            }\n        });\n        return intersection;\n    }\n\n    /**\n     * Given two sets, this returns a new set with all the elements that\n     * exist in your set but not in the other set.\n     *\n     * @param {Set} otherSet - Another Set\n     * @return {Set} difference - Return a difference set.\n     */\n    difference(otherSet: Set) {\n        let difference = new Set();\n\n        this.forEach(function(key: number, val: string, set: Set) {\n            if (!otherSet.has(val)) {\n                difference.add(val);\n            }\n        });\n\n        return difference;\n    }\n\n    /**\n     * Given two sets, confirm with a boolean if this is a subset of another set.\n     *\n     * @param {Set} otherSet - Another Set\n     * @return {boolean} isSubset - Return boolean true if this is a subset.\n     */\n    isSubset(otherSet: Set) {\n        let isSubset = false;\n        let counter = 0;\n\n        // if this set is bigger than the other set, it can't be a subset\n        if (this.size() <= otherSet.size()) {\n            // loop through all items, and check if my values\n            // also exist in the other set.\n            // all values will need to exist.\n            this.forEach(function(key: number, val: string, set: Set) {\n                if (otherSet.has(val)) {\n                    counter++;\n                }\n            });\n        }\n\n        if (counter === this.size()) {\n            isSubset = true;\n        }\n\n        return isSubset;\n    }\n}\n","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Map.ts\");","/**\n * Map Data Structure\n * @class Map\n * @author Lee Boonstra\n *\n *      # What do we know about Map?\n *      Set objects are collections of key value pairs\n *      The key can be used to find a particular element.\n *      Other names are Dictionary, Symbol table or Associative Arrays\n *\n *      In computer science, maps are often used to store the refefence address of an object.\n *      For example, look in your Developer Tools, Memory tab and look at the Snapshots\n */\nexport class Map {\n    private items: Object;\n    private total: number;\n\n    constructor() {\n        this.items = {}; // note it's an object, so you can store only one key.\n        this.total = 0;\n    }\n\n    /**\n     * Check if the key exist. If not, add a key value pair\n     *\n     * @param  {string} key - String name key will be used as key and value\n     * @param  {string} value - String name value will be used as key and value\n     */\n    set(key: string, value: string) {\n        let isCreated = false;\n        if (!this.hasKey(key.toString())) {\n            this.items[key] = value;\n            isCreated = true;\n            this.total++;\n        }\n        return isCreated;\n    }\n\n    /**\n     * Remove value from the set\n     *\n     * @param  {string} key - String name key will be used as key and value\n     */\n    remove(key: string) {\n        let isRemoved = false;\n        if (this.hasKey(key.toString())) {\n            delete this.items[key];\n            isRemoved = true;\n            this.total--;\n        }\n        return isRemoved;\n    }\n\n    /**\n     * Check if the key exist.\n     * Returns a boolean asserting whether a key is present in the Map.\n     *\n     * @param {string} key - the key\n     * @return {boolean} isExisting - Boolean, returns true if value exists in Map.\n     */\n    hasKey(key: string): Boolean {\n        let isExisting = false;\n        if (this.items[key]) {\n            isExisting = true;\n        }\n        return isExisting;\n    }\n\n    /**\n     * Get the value from a specific key\n     *\n     * @param {string} key - the key\n     * @return {string} value - the value from the key\n     */\n    get(key: string): String {\n        return this.items[key.toString()];\n    }\n\n    /**\n     * Returns an array with all the keys of the Set\n     *\n     * @return {array} keys - Array with all the keys of the set\n     */\n    keys() {\n        let arr = [];\n        for (let item in this.items) {\n            arr.push(item)\n        }\n\n        return arr;\n    }\n\n    /**\n     * Returns an array with all the values of the Set\n     *\n     * @return {array} values - Array with all the values of the set\n     */\n    values() {\n        let arr = [];\n        for (let item in this.items) {\n            arr.push(this.items[item]);\n        }\n\n        return arr;\n    }\n\n    /**\n    * Removes all elements from the Set object.\n    */\n    clear(): void {\n        this.items = {};\n        this.total = 0;\n    }\n\n    /**\n    * Returns the number of values in the Set object.\n    *\n    * @return {number} total - Total amount of items in Set\n    */\n    size(): number {\n        return this.total;\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @returns {boolean} isEmpty - if the Stack is empty or not\n    */\n    isEmpty(): Boolean {\n        return (this.total === 0);\n    }\n\n\n   /**\n    * Executes the callback function, for each item in the Set.\n    *\n    * @param {function} callback(key, val, set) - Callback function with 3 args key, value and set.\n    */\n    forEach(callback: Function) {\n        for (let key in this.items) {\n            callback(key, this.items[key], this.items);\n        }\n    }\n}\n","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./HashTable.ts\");","import { SimpleDict } from './SimpleDict';\n\n/**\n * HashTable Data Structure\n * @class HashTable\n * @author Lee Boonstra\n *\n *      # What do we know about HashMap?\n *      Very similar to Maps/Associative Arrays, for storing\n *      key value pairs. You can find a stored value in the shortest\n *      time possible, O(1), rather than looping though each\n *      array value O(n) or using a sorted binary array\n *      or Tree O(log n).\n *\n *      Think about a student is assigned a student number\n *      that can be used to find information about him.\n *\n *      To make sure all key values in a HashTable are short\n *      as possible, and are integers to do fast lookup,\n *      we will need a hashing function.\n *      You will need to find a good hashing function, one\n *      that doesn't take too long to create a hash (when inserting/\n *      getting or removing). But you also don't want to make it\n *      to simple so you create collisions.\n *\n *      Although hash tables provide fast insertion, deletion, and retrieval,\n *      they perform poorly for operations that involve searching, such as finding the\n *      minimum and maximum values in a data set. For these operations, other data structures\n *      such as the binary search tree are more appropriate. Access and Deletion in worst case O(n)\n *\n *      ## Real world examples in Software Engineering?\n *      Browser vendors use hashtables a lot.\n *      But also when you use a database, you would set indexes to allow faster searching\n *\n */\nexport class HashTable {\n    private table: any[];\n    private total: number;\n    public bucketSize: number;\n    private probe: boolean;\n    private uniqueKeys: boolean;\n\n    /**\n     * @param {Object} opt - (optional)\n     * @param {boolean} opt.probe - enable probing default false\n     * @param {number} opt.bucketSize - if bucketSize set, create max HashTable buckets total. Less buckets is higher chance on collisions. Default 0, use good hashing function.\n     * @param {boolean} opt.uniqueKeys - skip duplicate key names so keys are unique default true\n     */\n    constructor(opt: any) {\n        this.table = [];\n        this.total = 0;\n        this.bucketSize = (opt.bucketSize || 0);\n        this.probe = (opt.probe || false);\n        this.uniqueKeys = (opt.uniqueKeys || true)\n    }\n\n    /**\n     * Check if the key exist. If not, add a key value pair\n     *\n     * @param  {string} key - String name key will be used as key and value\n     * @param  {string} value - String name value will be used as key and value\n     */\n    put(key: string, value: string) {\n        let isCreated = false;\n        let hash = this.hashCode(key);\n        if (!this.hasHash(hash)) {\n            this.table[hash] = new SimpleDict();\n            this.table[hash].set(key, value);\n            isCreated = true;\n            this.total++;\n        } else {\n            if (this.probe) {\n                let index = hash + 1;\n                while (this.table[index] !== undefined) {\n                    index++;\n                }\n                this.table[index] = new SimpleDict();\n                this.table[index].set(key, value);\n                isCreated = true;\n                this.total++;\n            } else {\n                // the hash already exists\n                if (this.uniqueKeys && this.table[hash].keys[0] === key) {\n                    // but the key is not unique\n                    // please skip duplicate\n                    console.error(key + ' already exists in HashTable, so skipped.');\n                } else {\n                    // now I want not a SimpleDict but an Array\n                    if (this.table[hash].constructor === SimpleDict) {\n                        let current = this.table[hash];\n                        this.table[hash] = []; // TODO or a LinkedList\n                        this.table[hash].push(current);\n                    }\n                    // its an array, add the new item\n                    let newItem = new SimpleDict();\n                    newItem.set(key, value);\n                    this.table[hash].push(newItem);\n                    isCreated = true;\n                    this.total++;\n                }\n            }\n        }\n\n        return isCreated;\n    }\n\n\n\n    /**\n     * Remove key value pair from the HashMap. When Collision with LinkedList is enabled, it will remove all occurences.\n     * When not probing best case O(1) worst case O(n).\n     *\n     * @param  {string} key - String name key will be used as key and value\n     */\n    remove(key: string) {\n        let isRemoved = false;\n        let hash = this.hashCode(key);\n        // when probing is enabled, and the table size doesn't match\n        // the bucket size, we will need to probe again to find\n        // the key back.\n        if (this.probe && (this.table.length !== this.bucketSize)) {\n            let index = hash;\n            // keep looping through you find the key\n            while (this.table[index].keys[0] !== key) {\n                index++;\n            }\n            this.table[index].remove(key);\n            isRemoved = true;\n            this.total--;\n        } else {\n            this.table[hash].remove(key);\n            isRemoved = true;\n            this.total--;\n        }\n\n        return isRemoved;\n    }\n\n    /**\n     * Check if the hash exist.\n     * Returns a boolean asserting whether a key is present in the Map.\n     *\n     * @param {number} hash - the hash\n     * @return {boolean} isExisting - Boolean, returns true if value exists in Map.\n     */\n    hasHash(hash: number): boolean {\n        let isExisting = false;\n        if (this.table[hash]) {\n            isExisting = true;\n        }\n        return isExisting;\n    }\n\n    /**\n     * Get the KeyValue Object pair from a specific key\n     * When not probing best case O(1) worst case O(n)\n     *\n     * @param {string} key - the key\n     * @return {Object | Array } return KeyValue Object or incase of LinkedList collision, an array with multiples.\n     */\n    get(key: string) {\n        let hash = this.hashCode(key);\n        let itemValue = undefined;\n\n        // when probing is enabled, and the table size doesn't match\n        // the bucket size, we will need to probe again to find\n        // the key back.\n        if (this.probe && (this.table.length !== this.bucketSize)) {\n            let index = hash;\n            // keep looping through you find the key\n            while (this.table[index].keys[0] !== key) {\n                index++;\n            }\n            itemValue = this.table[index].get(key);\n        } else {\n            if (this.table[hash].constructor === SimpleDict) {\n                itemValue = this.table[hash].get(key);\n            } else {\n                // there are multiples with this hash\n                // so we have to loop\n                let i = 0;\n                while (key !== this.table[hash][i].keys[0]) {\n                    i++;\n                }\n                itemValue = this.table[hash][i].get(key);\n            }\n        }\n\n        return itemValue;\n    }\n\n    /**\n    * Removes all elements from the Set object.\n    */\n    clear(): void {\n        this.table = [];\n        this.total = 0;\n    }\n\n    /**\n    * Returns the number of values in the Set object.\n    *\n    * @return {number} total - Total amount of items in Set\n    */\n    size(): number {\n        return this.total;\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @returns {boolean} isEmpty - if the Stack is empty or not\n    */\n    isEmpty(): Boolean {\n        return (this.total === 0);\n    }\n\n   /**\n    * Executes the callback function, for each item in the Set.\n    *\n    * @param {function} callback(key, val, set) - Callback function with 3 args key, value and set.\n    */\n    forEach(callback: Function) {\n        for (let key in this.table) {\n            callback(key, this.table[key], this.table);\n        }\n    }\n\n    /**\n     * Create a hash based on a key string\n     * The Hash-function takes a key and converts it to a number which will be the index at which to store it.\n     * I am computing a hash value by summing the ASCII value of each character of the string\n     * , multiplying the ASCII value by a multiplier 'code', which in this case, is an odd prime 37.\n     * And the reason to choose 37 being, by some empirical research, if we take over 50,000 English words\n     * will produce less than 7 collisions in each case, while creating a hasing function.\n     *\n     * @param {string} key - the key\n     */\n    hashCode(key: string): number {\n        let hash = 0;\n        const code = 37;\n        for (let i = 0; i < key.length; i++) {\n          hash += code * hash + key.charCodeAt(i);\n        }\n        if (this.bucketSize !== 0) {\n            hash = hash % this.bucketSize;\n        }\n        return hash;\n    }\n}\n","/**\n * Simple Associative Array / Dictionary\n * @class SimpleDict\n * @author: Lee Boonstra\n *\n * A simple Associative Array / Matrix\n * Slow O(n)\n*/\nexport class SimpleDict {\n    private keys: any[];\n    private values: any[];\n    private total: number;\n\n    constructor() {\n        this.keys = [];\n        this.values = [];\n        this.total = 0;\n    }\n\n    /**\n    * Set key value pair in SimpleDict\n    * O(1)\n    * @param {string} key - the key value\n    * @param {any} value - the value\n    * @returns {Boolean} true if succesful created\n    */\n    set(key: string, value: any): Boolean {\n        this.keys.push(key);\n        this.values.push(value);\n        this.total++;\n\n        return true;\n    }\n\n    /**\n    * Remove key value pair in SimpleDict\n    * O(n)\n    * @param {string} key - the key value\n    * @returns {Boolean} true if succesful removed\n    */\n    remove(key: string): Boolean {\n        let isRemoved = false;\n        for (let i = 0; i < this.keys.length; i++) {\n            if (this.keys[i] === key) {\n                delete this.keys[i];\n                delete this.values[i];\n                this.total--;\n                isRemoved = true;\n            }\n        }\n        return isRemoved;\n    }\n\n    /**\n    * Get value from SimpleDict\n    * O(n)\n    * @param {string} key - the key value\n    * @returns {any} value - the value that belongs to the key\n    */\n    get(key: string): any {\n        for (let i = 0; i < this.keys.length; i++) {\n            if (this.keys[i] === key) {\n                return this.values[i];\n            }\n        }\n    }\n\n   /**\n     * Check if the key exist.\n     * Returns a boolean asserting whether a key is present in the Map.\n     *\n     * @param {string} key - the key\n     * @return {boolean} isExisting - Boolean, returns true if value exists in Map.\n     */\n    hasKey(key: string): Boolean {\n        return (this.get(key) ? true : false);\n    }\n\n    /**\n    * Get total size from SimpleDict\n    * O(1)\n    * @returns {number} total - the size of the SimpleDict\n    */\n    size(): number {\n        return this.total;\n    }\n\n    /**\n    * Checks if SimpleDict is empty\n    * O(1)\n    * @returns {boolean} isEmpty\n    */\n    isEmpty(): boolean {\n        return this.total === 0;\n    }\n\n    /**\n    * Clear the SimpleDict\n    * O(1)\n    * @returns {number} total - the size of the SimpleDict\n    */\n    clear(): number {\n        this.keys = [];\n        this.values = [];\n        this.total = 0;\n        return this.total;\n    }\n}","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Tree.ts\");","/**\n * TreeNode DataStructure\n * @class TreeNode\n * @author Lee Boonstra\n *\n */\nexport class TreeNode {\n    public key: number;\n    public left: TreeNode;\n    public right: TreeNode;\n\n    constructor(key: number, left: TreeNode = null, right: TreeNode = null) {\n        this.key = key;\n        this.left = left;\n        this.right = right\n    }\n}\n\n/**\n * Tree DataStructure\n * @class Tree\n * @author Lee Boonstra\n *\n *      # What do we know about Trees?\n *      A Tree is a non-linear data structure where data objects\n *      are organized in terms of hierarchical relationship.\n *      The structure is non-linear in the sense that,\n *      unlike simple array and linked list implementation,\n *      data in a tree is not organized linearly. Each data\n *      element is stored in a structure called a node.\n *\n *      Think about an organization chart of family tree.\n *\n *      ## BinarySearchTree (BST)\n *      A Node in a Tree can have multiple branches. In a BST\n *      the BST Node can only have 2 branches. One on the left,\n *      and one on the right. They are ordered. The left branch\n *      have values that are <= (lower or equal) than the parent node.\n *      The right branch has values that are => than the parent node.\n *      Therefore each lookup, insertion or deletion takes time\n *      in proporsional to the logarithm (log) of the number of the\n *      total items in the tree. (You can skip half of the tree).\n *      O(log n) instead of O(n) when sorting an array. However it is\n *      slower than the operations than a hashtable O(1).\n *\n *      ## Depth First Search (DFS)\n *\n *      ## Breadth First Search (BFS)\n *\n *      ## Real world examples in Software Engineering?\n *      DOM (Document Object Model)\n */\nexport class BinarySearchTree {\n    private root: TreeNode;\n\n    constructor() {\n        this.root = null;\n    }\n\n    // findMinNode()\n    // search(node, data)\n\n    /**\n     * Get the Root Node Value\n     * @returns {number | null} The Root Node Value\n     */\n    getRootNodeValue(): any {\n        let key = null;\n        if (this.root !== null) {\n            key = this.root.key;\n        }\n        return key;\n    }\n\n    /**\n     * Insert a node to a tree\n     * @param {number} key\n     */\n    insert(key: number) {\n        const node = this.root;\n        if (node == null) {\n            // this is the root node\n            // create a node based on this key\n            this.root = new TreeNode(key)\n            return;\n        } else {\n            // it's not the root node,\n            // so we will need to figure\n            // where to place this in the tree.\n            // let's use a recursive funciton\n            const searchTree = function(node: TreeNode): void {\n                // the key is smaller the parent node\n                if (key < node.key) {\n                    // when there are no nodes on the left side\n                    // we can start creating a node\n                    if (node.left == null) {\n                        // put it on the left side of the tree\n                        node.left = new TreeNode(key);\n                        return;\n                    } else if (node.left !== null) {\n                        // there are already nodes on the left\n                        // so we use a recursive function\n                        // passing in the node.left we just saw\n                        searchTree(node.left)\n                    }\n                } else if (key > node.key) {\n                    // when there are no nodes on the right side\n                    // we can start creating a node\n                    if (node.right == null) {\n                        // put it on the right side of the tree\n                        node.right = new TreeNode(key);\n                        return;\n                    } else if (node.right !== null) {\n                        // there are already nodes on the right\n                        // so we use a recursive function\n                        // passing in the node.right we just saw\n                        searchTree(node.right)\n                    } else {\n                        // the key must be equal. we won't add\n                        // it to the tree, we skip duplicates\n                        return null;\n                    }\n                }\n            }\n            // we will call the function\n            return searchTree(node);\n        }\n    }\n\n    /**\n     * This method returns the minimum value/key in the tree\n     */\n    min(): number {\n        let current = this.root;\n        // a while loop, continue searching\n        // till you are on the end of the left branch\n        while (current.left !== null && current.left !== undefined) {\n            current = current.left;\n        }\n        return current.key;\n    }\n\n    /**\n     * This method returns the maximum value/key in the tree\n     */\n    max(): number {\n        let current = this.root;\n        // a while loop, continue searching\n        // till you are on the end of the left branch\n        while (current.right != null) {\n            current = current.right;\n        }\n        return current.key;\n    }\n\n    /**\n     * This method searches for the key in the tree. It\n     * returns true if it exist and false if the node\n     * does not exist.\n     * @param {number} key - Key to search for\n     */\n    contains(key: number): boolean {\n        return (this.find(key) !== null)\n    }\n\n    /**\n     * This method searches for the key in the tree. It\n     * returns the TreeNode.\n     * @param {number} key - Key to search for\n     * @returns {TreeNode} - return node\n     */\n    find(key: number): TreeNode {\n        let current = this.root;\n        // when the current node is not null\n        while (current) {\n            // is it the current key?\n            if (key === current.key) {\n                // yep, found it\n                return current;\n            } else if (key < current.key) {\n                // value is lower than the parent\n                // let's look left\n                current = current.left;\n            } else {\n                // value is higher than the parent\n                // let's look right\n                current = current.right;\n            }\n            // haven't found it so continue looking\n        }\n        // we didn't find it, the key might be not in the tree\n        return null;\n    }\n\n    /**\n     * Removes a node in a tree.\n     * @param {number} data\n     */\n    remove(key: number) {\n        const removeNode = function(node: TreeNode, key: number): TreeNode {\n            if (node == null) {\n                // we have an empty tree\n                return null;\n            }\n            // can we find the data in the tree\n            if (key === node.key) {\n                // when the value is in the tree,\n                // there are 4 options:\n\n                // 1)\n                // node has no children, means its a leaf node\n                // we can just delete that node by setting\n                // the data of that node to null. (removing pointers)\n                if (node.left === null && node.right === null) {\n                    return null;\n                }\n\n                // 2)\n                // node has no left child\n                // we will replace pointers\n                // the parent node will get\n                // the right node from the to be deleted node\n                // as a new pointer\n                if (node.left === null) {\n                    return node.right;\n                }\n\n                // 3)\n                // node has no right child\n                // we will replace pointers\n                // the parent node will get\n                // the left node from the to be deleted node\n                // as a new pointer\n                if (node.right === null) {\n                    return node.left;\n                }\n\n                // 4)\n                // node has both children\n                // this is a bit more complicated\n                // cause you can't replace pointers\n                // of one, cause what would happen to the\n                // other child.\n\n                // we will first look to the right node\n                let tempNode = node.right;\n                // and find the min in the branch by\n                // looking all the way left\n                while (tempNode.left !== null) {\n                    tempNode = tempNode.left;\n                };\n                // the node that will need to be deleted\n                // gets the node data from the tempNode\n                // the one from all the way left\n                node.key = tempNode.key;\n\n                // and we will need to go back in this function\n                // again to make sure we re-link all the other\n                // pointers\n                node.right = removeNode(node.right, tempNode.key);\n                return node;\n            } else if (key < node.key) {\n                node.left = removeNode(node.left, key);\n                return node;\n            } else {\n                node.right = removeNode(node.right, key);\n                return node;\n            }\n        }\n        // call the recursive function, start with the root\n        this.root = removeNode(this.root, key);\n    }\n\n\n    /**\n     * Get the Tree Min Height\n     * Recursive Function\n     * @param {TreeNode} node - (default) rootNode\n     * @returns {number} minHeight - of the tree\n     */\n    getMinHeight(node = this.root): number {\n        if (node == null) {\n            // every time when you reach the leaf node\n            // return -1, so it's a number;\n            return -1;\n        }\n\n        // when node is not null, so it's not a leaf\n        // call this function again, passing in the\n        // previous node, that way you are walking\n        // through all the lefts, and all the rights.\n        let leftBranch = this.getMinHeight(node.left);\n        let rightBranch = this.getMinHeight(node.right);\n\n        // when the left branche is smaller\n        // start walking left, otherwise\n        // walk through the right branche\n        // and start counting (+1) till the end (null)\n\n        // the branch that's the smallest\n        // will contain the min height\n        if (leftBranch < rightBranch) {\n            return leftBranch + 1;\n        } else {\n            return rightBranch + 1;\n        }\n    }\n\n    /**\n     * Get the Tree Max Height\n     * @param {TreeNode} node - (default) rootNode\n     * @returns {number} maxHeight - of the tree\n     */\n    getMaxHeight(node = this.root): number {\n        if (node == null) {\n            // every time when you reach the leaf node\n            // return -1, so it's a number;\n            return -1;\n        }\n\n        // when node is not null, so it's not a leaf\n        // call this function again, passing in the\n        // previous node, that way you are walking\n        // through all the lefts, and all the rights.\n        let leftBranch = this.getMaxHeight(node.left);\n        let rightBranch = this.getMaxHeight(node.right);\n\n        // when the left branche is bigger\n        // start walking left, otherwise\n        // walk through the right branche\n        // and start counting (+1) till the end (null)\n\n        // the branch that's the biggest\n        // will contain the max height\n        if (leftBranch > rightBranch) {\n            return leftBranch + 1;\n        } else {\n            return rightBranch + 1;\n        }\n    }\n\n    /**\n     * Is Tree Balanced? A tree is balanced when the branches are equal or have 1 level difference.\n     * @returns {boolean} if the Tree is Balanced\n     */\n    isBalanced(): boolean {\n        return(this.getMinHeight()\n            >= this.getMaxHeight() - 1);\n    }\n\n    /**\n     * Traverse the tree\n     * @param {object} opt\n     * @param {string} opt.method - inOrder | preOrder | postOrder | levelOrder (default inOrder); \n     * @returns {array} - sorted array\n     */\n    traverse(opt: any): any {\n        let array = new Array();\n        let method = \"\";\n        if (opt.method) {\n            method = opt.method.toLowerCase();\n        }\n        console.log(method);\n        switch (method) {\n            case \"inorder\":\n                array = this.inorder();\n                break;\n            case \"preorder\":\n                array = this.preorder();\n                break;\n            case \"postorder\":\n                array = this.postorder();\n                break;\n            case \"levelorder\":\n                array = this.levelorder();\n                break;\n            default:\n                array = this.inorder();\n        }\n\n        return array;\n    }\n\n    /**\n     * Traverses nodes of a tree with DFS\n     * @returns {array} - return an inorder array\n     */\n    inorder(): any[] {\n        if (this.root == null) {\n            // check if there's a BST\n            // and if there are values\n            // in it\n            console.log(\"root = null\");\n            return null;\n        } else {\n            let result = new Array();\n            // recursive function\n            function traverseInOrder(node: TreeNode) {\n                // we start from the root node.\n\n                // if the current node has a node.left\n                // then call this function\n                // again but pass in the left node\n                // else ignore\n                // if (node.left) console.log(\"execute if node \" + node.key + \" has a left: \" + node.left.key);\n                node.left && traverseInOrder(node.left);\n\n                // and then add the value to the array\n                // so for everytime you called the \n                // function, you still will add values\n                // to the array\n                // console.log(\"push in array \" + node.key);\n                result.push(node.key);\n\n                // next, check if the current node has\n                // a right node. else ignore\n                // in case not, go up\n                // pass that node to the array\n\n                // if node.right does exist call this function\n                // again but pass in the right node\n                // if (node.right) console.log(\"execute if node \" + node.key + \" has a right: \" + node.right.key);\n                node.right && traverseInOrder(node.right);\n            }\n            traverseInOrder(this.root);\n            return result;\n        }\n    }\n\n    /**\n     * Traverses nodes of a tree with BFS\n     * @returns {array} - return an preorder array\n     */\n    preorder(): any[] {\n        if (this.root == null) {\n            // check if there's a BST\n            // and if there are values\n            // in it\n            return null;\n        } else {\n            let result = new Array();\n            // recursive function\n            function traversePreOrder(node: TreeNode) {\n                // add the key in the results array\n                result.push(node.key);\n                // if node.left exist call this function\n                // again but pass in the left node\n                node.left && traversePreOrder(node.left);\n                // if node.right exist call this function\n                // again but pass in the right node\n                node.right && traversePreOrder(node.right);\n            }\n            traversePreOrder(this.root);\n            return result;\n        }\n    }\n\n    /**\n     * Traverses nodes of a tree with BFS\n     * @returns {array} - return an postorder array\n     */\n    postorder(): any[] {\n        if (this.root == null) {\n            // check if there's a BST\n            // and if there are values\n            // in it\n            return null;\n        } else {\n            let result = new Array();\n            // recursive function\n            function traversePostOrder(node: TreeNode) {\n                // if node.left exist call this function\n                // again but pass in the left node\n                node.left && traversePostOrder(node.left);\n                // if node.right exist call this function\n                // again but pass in the right node\n                node.right && traversePostOrder(node.right);\n                // add the key in the results array\n                result.push(node.key);\n            }\n            traversePostOrder(this.root);\n            return result;\n        }\n    }\n\n    /**\n     * Traverses nodes for each level\n     * @returns {array} - return an level order array\n     */\n    levelorder(): any {\n        let results = [];\n        let queue = [];\n        if (this.root != null) {\n            queue.push(this.root);\n            // now we will loop\n            // as long as there are\n            // items in the queue\n            while (queue.length > 0) {\n                let node = queue.shift();\n                // takes the first element in the\n                // array and remove that element\n                // so we will start with the rootnode\n                // in the queue. and after shifting\n                // it's not in the queue anymore\n\n                // we can put the key in the results array\n                results.push(node.key);\n\n                if (node.left != null) {\n                    // console.log(node.key + \" has a left node: \" + node.left.key)\n                    // when there is a left node\n                    // we can put it to the queue\n                    // so the while loop won't stop\n                    queue.push(node.left);\n                }\n                if (node.right != null) {\n                    // console.log(node.key + \" has a right node: \" + node.right.key)\n            \n                    // when there is a right node\n                    // we can put it to the queue\n                    // so the while loop won't stop\n                    queue.push(node.right);\n                }\n\n                // when there are items in the queue,\n                // we can start adding it to the results\n                // array, and start checking for the next\n                // level.\n            }\n            return results;\n        } else {\n            return null;\n        }\n    }\n}","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Graph.ts\");","import { Queue } from '../datastructures/Queue';\nimport { SimpleDict } from '../datastructures/SimpleDict';\n\n/**\n * Each node object  / Vertex\n * @class GraphNode\n * @author Lee Boonstra\n * @param {string} id - string with the node id\n */\nexport class GraphNode {\n    public id: string;\n    public adjacents: Array<string>;\n\n    constructor(id: string) {\n        this.id = id;\n        this.adjacents = new Array();\n    }\n}\n\n/**\n * Create a Graph\n * @class Graph\n * @author Lee Boonstra\n * @param {array} nodeIds - An array with all the string ids to be created\n * @param {array} matrix - A 2 dimensional array (matrix), used as an adjacency list\n */\nexport class Graph {\n    private vertices: Object;\n    private nodeIds: any[];\n    public matrix: any[];\n\n    constructor (nodeIds: Array<string>, matrix: any) {\n        this.matrix = matrix;\n        this.nodeIds = nodeIds;\n        this.vertices = {};\n\n        // the matrix should have for each row a vertex\n        if (nodeIds.length !== this.matrix.length) {\n            throw \"The size of the matrix doesn't contain the total of vertices\";\n        }\n\n        // loop through the array rows\n        for (let i = 0; i < matrix.length; i++) {\n            // create a vertex node, for each row in the matrix\n            let node = new GraphNode(this.nodeIds[i]);\n\n            // loop through all the adjacents\n            for (let j = 0; j < this.matrix[i].length; j++) {\n                // Add the adjacent, when it's marked\n                // as one in the matrix.\n                if (matrix[i][j] === 1) {\n                    node.adjacents.push(this.nodeIds[j]);\n                }\n            }\n\n            // each vertex gets a row in the vertices array\n            this.vertices[node.id] = node;\n        }\n\n        console.log(this.vertices);\n    }\n\n\n\n    /**\n     * Get the Node that belongs to a particular node id.\n     * @param {number} nodeId - Node id to look for\n     * @returns {Node} node - The matching node\n     */\n    getNode(nodeId: string): GraphNode {\n        return this.vertices[nodeId];\n    }\n\n    addNode() {\n\n\n\n\n    }\n\n    addEdge() {\n\n    }\n\n    /**\n     * Check if Path exist via Depth First Search\n     * Go deep into nodes, before exploring other nodes.\n     * Recursive Function\n     * @param {string} startId - The Node Id to start searching from\n     * @param {string} destinationId = The Node Id that needs to be found\n     * @returns {boolean} pathExists = return true if a path was found\n     */\n    public hasPathDfs(startId: string, destinationId: string): boolean {\n        let pathExists = false;\n        let source = this.getNode(startId);\n        let destination = this.getNode(destinationId);\n        let visited = new SimpleDict();\n\n        pathExists = this._hasPathDfs(source, destination, visited);\n\n        return pathExists;\n    }\n\n\n    /**\n     * Check if Path exist via Depth First Search\n     * Go deep into nodes, before exploring other nodes.\n     * Recursive Function\n     * @param {GraphNode} source - The Node to start searching from\n     * @param {GraphNode} destination - The Node that needs to be found\n     * @param {SimpleDict} visited - A Simple Dictionary holding the references to the visisted vertices\n     * @returns {boolean} pathExists - return true if a path was found\n     */\n    private _hasPathDfs(source: GraphNode, destination: GraphNode, visited: SimpleDict): boolean {\n        if (visited.hasKey(source.id)) {\n            // you have visited the node before\n            // this is also the part thats would\n            // stop the recursive function\n            return false;\n        }\n\n        visited.set(source.id, true);\n\n        // the node you are looking for\n        // is the same as the destination\n        if (source.id === destination.id) {\n            return true;\n        }\n\n        // now look into its adjacents\n        for (let id of source.adjacents) {\n            let node = this.getNode(id);\n            // recursive, keep looking in its neighbors\n            if (this._hasPathDfs(node, destination, visited)) return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if Path exist via Breath First Search\n     * Go wide, and first check all neighbor nodes. (adjacents) before going deep.\n     * Need a Queue for this\n     * @param {string} startId - The Node Id to start searching from\n     * @param {string} destinationId = The Node Id that needs to be found\n     * @returns {boolean} pathExists = return true if a path was found\n     */\n    public hasPathBfs(startId: string, destinationId: string): boolean {\n        let pathExists = false;\n        let source = this.getNode(startId);\n        let destination = this.getNode(destinationId);\n        let visited = new SimpleDict();\n\n        pathExists = this._hasPathBfs(source, destination, visited);\n\n        return pathExists;\n    }\n\n\n    /**\n     * Check if Path exist via Breath First Search\n     * Go wide, and first check all neighbor nodes. (adjacents) before going deep.\n     * Need a Queue for this\n     * @param {GraphNode} source - The Node to start searching from\n     * @param {GraphNode} destination - The Node that needs to be found\n     * @param {SimpleDict} visited - A Simple Dictionary holding the references to the visisted vertices\n     * @returns {boolean} pathExists - return true if a path was found\n     */\n    private _hasPathBfs(source: GraphNode, destination: GraphNode, visited: SimpleDict): boolean {\n        let queue = new Queue();\n        queue.add(source);\n\n        while (!queue.isEmpty()) {\n            // as long as there are items in the queue\n            // keep running this\n\n            // get the item from the queue\n            let node = queue.remove();\n\n            // the node you are looking for\n            // is the same as the destination\n            if (node === destination) {\n                return true;\n            }\n\n            if (visited.hasKey(node.id)) {\n                // you have visited the node before\n                // the continue statement \"jumps over\" one iteration in the loop.\n                continue;\n            }\n\n            visited.set(node.id, true);\n\n            // now look into its adjacents\n            for (let id of node.adjacents) {\n                let neighbor = this.getNode(id);\n                queue.add(neighbor);\n            }\n        }\n\n        return false;\n    }\n}\n","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Sorters.ts\");","/**\n * Array Sorters\n * @class Sorters\n * @author Lee Boonstra\n */\nexport class Sorters {\n    public values: Array<string>;\n    constructor(id: string) {\n\n    }\n}"],"sourceRoot":""}