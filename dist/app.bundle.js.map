{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../node_modules/webpack/buildin/global.js-exposed","webpack:///./ts/datastructures/SimpleDict.ts-exposed","webpack:///./ts/datastructures/Stack.ts-exposed","webpack:///./ts/datastructures/Queue.ts-exposed","webpack:///./index.ts-exposed","webpack:///../node_modules/webpack/buildin/global.js","webpack:///./index.ts","webpack:///./ts/datastructures/Stack.ts","webpack:///./ts/datastructures/Queue.ts","webpack:///./ts/datastructures/LinkedList.ts-exposed","webpack:///./ts/datastructures/LinkedList.ts","webpack:///./ts/datastructures/Set.ts-exposed","webpack:///./ts/datastructures/Set.ts","webpack:///./ts/datastructures/Map.ts-exposed","webpack:///./ts/datastructures/Map.ts","webpack:///./ts/datastructures/HashTable.ts-exposed","webpack:///./ts/datastructures/HashTable.ts","webpack:///./ts/datastructures/SimpleDict.ts","webpack:///./ts/datastructures/Tree.ts-exposed","webpack:///./ts/datastructures/Tree.ts","webpack:///./ts/datastructures/Graph.ts-exposed","webpack:///./ts/datastructures/Graph.ts","webpack:///./ts/algorithms/Sorters.ts-exposed","webpack:///./ts/algorithms/Sorters.ts","webpack:///./ts/hackerrank/TwoStrings.ts-exposed","webpack:///./ts/hackerrank/TwoStrings.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","global","g","this","Function","e","window","Stack_1","Queue_1","LinkedList_1","Set_1","Map_1","HashTable_1","Tree_1","Graph_1","SimpleDict_1","Sorters_1","TwoStrings_1","Stack","Queue","LinkedList","Set","Map","HashTable","BinarySearchTree","Graph","SimpleDict","Sorters","SubStringSet","[object Object]","items","total","item","undefined","isEmpty","count","length","Node","node","next","head","last_node","getHead","setHead","index","isInserted","size","newNode","previous","getNodeAt","current","console","log","values","indexOf","removeAt","isRemoved","error","arr","push","isCreated","has","isExisting","parseInt","callback","otherSet","unionSet","forEach","val","set","add","intersection","difference","isSubset","counter","hasKey","toString","opt","table","bucketSize","probe","uniqueKeys","hash","hashCode","hasHash","keys","constructor","newItem","remove","itemValue","charCodeAt","TreeNode","left","right","root","searchTree","find","removeNode","tempNode","leftBranch","getMinHeight","rightBranch","getMaxHeight","array","Array","method","toLowerCase","inorder","preorder","postorder","levelorder","result","traverseInOrder","traversePreOrder","traversePostOrder","results","queue","shift","GraphNode","id","adjacents","nodeIds","matrix","vertices","j","nodeId","startId","destinationId","history","source","getNode","destination","visited","_bfs","_dfs","pathExists","stack","pop","neighbor","_quicksort","leftPos","rightPos","pivot","_partition","_swap","temp","exists","newSet","myVal"],"mappings":"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","file":"app.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","module.exports = global[\"Library\"] = require(\"-!./global.js\");","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./SimpleDict.ts\");","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Stack.ts\");","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Queue.ts\");","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./index.ts\");","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import { Stack } from \"./ts/datastructures/Stack\";\nimport { Queue } from \"./ts/datastructures/Queue\";\nimport { LinkedList } from \"./ts/datastructures/LinkedList\";\nimport { Set } from \"./ts/datastructures/Set\";\nimport { Map } from \"./ts/datastructures/Map\";\nimport { HashTable } from \"./ts/datastructures/HashTable\";\nimport { BinarySearchTree } from \"./ts/datastructures/Tree\";\nimport { Graph } from \"./ts/datastructures/Graph\";\nimport { SimpleDict } from \"./ts/datastructures/SimpleDict\";\n\nimport { Sorters } from \"./ts/algorithms/Sorters\";\nimport { SubStringSet } from \"./ts/hackerrank/TwoStrings\";\n\nmodule.exports =  { Stack, Queue, LinkedList, Set, Map,\n    HashTable, BinarySearchTree, Graph, SimpleDict,\n    Sorters, SubStringSet}\n","/**\n * Stack Data Structure\n * @class Stack\n * @author Lee Boonstra\n *\n *      # What do we know about Stacks?\n *      It's a sequential data structure with LIFO. Last In - First Out principle.\n *      (and FILO First in - Last Out)\n *      Compare this to a deck of cards. The last card on top, is the first\n *      card to be removed from the pile. The base card, will be last.\n *\n *      ## Real world examples in Software Engineering?\n *      The browser history. Clipboard history.\n *      In the Sencha Ext JS framework there was a card layout / animation.\n *      The deck of cards in Hearthstone.\n */\nexport class Stack {\n    private items: any[];\n    private total: number;\n\n    constructor() {\n        // Based on an Array\n        this.items = [];\n        // Set the total to 0;\n        this.total = 0;\n    }\n\n    /**\n     * Add a new item to the top of the stack.\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @param {any} item - item\n     */\n    push(item: any) {\n        // this.items.push(item);\n        // We can only add one at a time\n        this.items[this.total] = item;\n        this.total++;\n    }\n\n    /**\n     * Pops / Removes the top item from the stack.\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @return {any} item - removed item\n     */\n    pop(): any {\n        let item = undefined;\n        if (!this.isEmpty()) {\n            this.total--;\n            // return this.items.pop();\n            // manual remove\n            item = this.items[this.total];\n            delete this.items[this.total];\n        }\n        return item;\n    }\n\n    /**\n    * Return the top item from the stack.\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return {item} item - top item\n    */\n    peek(): any {\n        if (this.isEmpty()) return undefined;\n\n        let i = this.total - 1;\n        return this.items[i];\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @returns {boolean} isEmpty - if the Stack is empty or not\n    */\n    isEmpty(): Boolean {\n        return (this.total === 0);\n    }\n\n    /**\n    * Removes all the items from the Stack\n    * Take O(1) time. We do not run any loop in any of these operations.\n    */\n    clear() {\n        if (!this.isEmpty()) {\n            this.items = [];\n            this.total = 0;\n        }\n    }\n\n    /**\n    * Return the total number of items from the stack\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return {number} size - total length of Stack\n    */\n    size(): number {\n        // Note: in this example this.items.length would be wrong\n        // since we are removing values from the array\n        // the array is not shifting.\n        return this.total;\n    }\n\n    /**\n     * Print stack\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @return {array} - array with items\n     */\n    values(): any[] {\n        return this.items;\n    }\n}\n","/**\n * Queue Data Structure\n * @class Queue\n * @author Lee Boonstra\n *\n *      # What do we know about Queues?\n *      It's a sequential data structure with FIFO. First In - First Out principle.\n *      (and LILO Last in - Last Out)\n *      Compare this to the line in at the bakery. First person in the line, takes\n *      a ticket from the counting machine, and will be served first, based on the counter.\n *\n *      ## Real world examples in Software Engineering?\n *      Printer Queue.\n */\nexport class Queue {\n    private items: any[];\n    private total: number; // total items in the queue\n    private count: number; // item count who will be served first\n\n    constructor() {\n        // Based on an Array\n        this.items = [];\n        // A queue needs at least one person.\n        this.total = 1;\n        // Set the count to 0\n        // Compared to Stacks, this is what makes this class different!\n        this.count = 0;\n    }\n\n    /**\n     * Add a new item to the back of the queue.\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @param item any\n     */\n    add(item: any) {\n        this.items[this.items.length] = item;\n        this.total++;\n    }\n\n    /**\n     * Retrieves and removes the head of this queue.\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @return removed item\n     */\n    remove(): any {\n        let item = undefined;\n        if (!this.isEmpty()) {\n            // which item will be first in the queue\n            // is is based on the counting system\n            item = this.items[this.count];\n            // remove this item from the queue\n            delete this.items[this.count];\n            // the queue size is now shorter\n            this.total--;\n            // but the number counter goes up\n            this.count++;\n        }\n        return item;\n    }\n\n    /**\n    * Return the the head of the queue\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return removed item\n    */\n    peek(): any {\n        if (this.isEmpty()) return undefined;\n\n        return this.items[this.count];\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return Boolean\n    */\n    isEmpty(): Boolean {\n        return (this.total <= 1);\n    }\n\n    /**\n    * Removes all the items from the Stack\n    * Take O(1) time. We do not run any loop in any of these operations.\n    */\n    clear() {\n        if (!this.isEmpty()) {\n            this.items = [];\n            this.total = 1;\n            this.count = 0; // reset counter\n        }\n    }\n\n    /**\n    * Return the total number of items from the stack\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return number\n    */\n    size(): number {\n        // Note: in this example this.items.length would be wrong\n        // since we are removing values from the array\n        // the array is not shifting.\n\n        return this.total - 1;\n    }\n\n    /**\n     * Print stack\n     * Take O(1) time. We do not run any loop in any of these operations.\n     *\n     * @return items\n     */\n    values(): any[] {\n        return this.items;\n    }\n}\n","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./LinkedList.ts\");","/**\n * LinkedList Data Structure\n * @class Node\n * @author Lee Boonstra\n *\n *      # What do we know about LinkedLists?\n *\n *      It's a sequential data structure and has\n *      similarities with an Array (also called a List).\n *      In other languages, an Array has a predefined\n *      size. Inserting and Removing items can be\n *      expensive. Because elements needs to be shifted\n *      over. A LinkedList is a dynamic data structure. We\n *      can add and remove items from it and it will grow\n *      when required. Elements are not placed\n *      contiguously in memory. Each node stores the\n *      element itself and also a reference (pointer\n *      link). Think about this as christmas lights. In\n *      order to find a broken light, you have to visit\n *      each light from beginning (head) to end (tail).\n *\n *      ## Real world examples in Software Engineering?\n *\n *      History and Subversioning? A trial of revisions\n *      and you can add branches?\n */\nexport class Node {\n    public node: Node;\n    public next: Node; // pointer\n    constructor(item: any) {\n        this.node = item;\n        this.next = undefined;\n    }\n}\n\n/**\n * LinkedList Data Structure\n * @class LinkedList\n * @author Lee Boonstra\n *\n *      # What do we know about LinkedLists?\n *\n *      It's a sequential data structure and has\n *      similarities with an Array (also called a List).\n *      In other languages, an Array has a predefined\n *      size. Inserting and Removing items can be\n *      expensive. Because elements needs to be shifted\n *      over. A LinkedList is a dynamic data structure. We\n *      can add and remove items from it and it will grow\n *      when required. Elements are not placed\n *      contiguously in memory. Each node stores the\n *      element itself and also a reference (pointer\n *      link). Think about this as christmas lights. In\n *      order to find a broken light, you have to visit\n *      each light from beginning (head) to end (tail).\n *\n *      ## Real world examples in Software Engineering?\n *\n *      History and Subversioning? A trial of revisions\n *      and you can add branches?\n */\nexport class LinkedList {\n    private head: Node;\n    private total: number;\n\n    constructor() {\n        // when you create a LinkedList the head is empty\n        this.head = null;\n        this.total = 0;\n    }\n\n    /**\n    * Add new item to the end of the LinkedList\n    * Take O(n) time. Loop to figure out the last node.\n    *\n    * @param item: any\n    * @return isAdded Boolean\n    */\n    push(item: any): Boolean {\n        const node = new Node(item);\n        let last_node;\n\n        if (this.getHead() == null) {\n            // the list is empty, adding a new item\n            this.setHead(node);\n        } else {\n            // the list is not empty, append items\n            last_node = this.getHead();\n            // start from the head, keep iterating, till\n            // you find the last node (tail, which is the node with next = null)\n            while (last_node.next != null) {\n                last_node = last_node.next;\n            }\n\n            last_node.next = node;\n        }\n        this.total++;\n\n        return true;\n    }\n\n    /**\n    * Insert a new item at a specified position in the\n    * LinkedList.\n    * Take O(n) time. To find the previous node, we will need to loop.\n    *\n    * @param index: number\n    * @param item: any\n    * @return isInserted Boolean\n    */\n    insert(index: number, item: any): Boolean {\n        let isInserted = false;\n        if (index >= 0 && index <= this.size()) {\n            const newNode = new Node(item);\n\n            if (index === 0) {\n                // This will be the head node.\n                this.setHead(newNode);\n                // update all the references\n            } else {\n                // iterate through all the nodes before the to be added node.\n                // and set a pointer to the next node\n                let previous = this.getNodeAt(index - 1);\n                let current = previous.next;\n                newNode.next = current;\n                previous.next = newNode;\n            }\n\n            console.log(this.values());\n            this.total++;\n        } else {\n            isInserted = false;\n        }\n\n        return isInserted;\n    }\n\n   /**\n    * Get the very first item in the LinkedList\n    *\n    * @return head: Node\n    */\n    getHead(): Node {\n        return this.head;\n    }\n\n  /**\n    * Set the very first item in the LinkedList\n    *\n    * @param node: Node\n    */\n    setHead(node: Node): void {\n        this.head = node;\n    }\n\n   /**\n    * Get the index of a specific node in the\n    * LinkedList. Returns -1 if it doesn't exist.\n    * Take O(n) time. To find the item, you will need to visit all the nodes\n    *\n    * @param node\n    * @return index: number | -1\n    */\n    indexOf(item: any): number {\n        let index = -1;\n        let node = this.getHead();\n        // keep iterating through the total amount of nodes\n        // till you reach the end (node = null and total)\n        for (let i = 0; i < this.total && node != null; i++) {\n            // this should be the one\n            if (item === node.node) {\n                index = i;\n            }\n            node = node.next;\n        }\n\n        return index;\n    }\n\n    /**\n    * Get the item of a specific index in the\n    * LinkedList. Returns undefined if it doesn't exist.\n    * Take O(n) time. To find the item, you will need to visit all the nodes\n    *\n    * @param index: number\n    * @return node: Node | undefined\n    */\n    getNodeAt(index: number): Node {\n        let node = undefined;\n\n        if (index >= 0 && index <= this.total) {\n            node = this.getHead();\n\n            // keep iterating till you reach the index\n            for (let i = 0; i < index && node != null; i++) {\n                node = node.next;\n            }\n\n        }\n\n        return node;\n    }\n\n    /**\n     * Removes an item from the LinkedList.\n     * Take O(n) time. To find the item to be removed, you will need to visit all the nodes\n     *\n     * @param item: any\n     * @return isRemoved Boolean\n     */\n    remove(item: any): Boolean {\n        let index = this.indexOf(item);\n        let result = this.removeAt(index);\n\n        return result;\n    }\n\n    /**\n     * Removes item from a specified index in the LinkedList.\n     * Take O(n) time. To find the item to be removed, you will need to visit all the nodes.\n     *\n     * @param position: number\n     * @return isRemoved Boolean\n     */\n    removeAt(index: number): Boolean {\n        let isRemoved = false;\n        if (index < 0) {\n            // throw \"Can't remove, because item is not in the LinkedList.\";\n            console.error(\"Can't remove, because item is not in the LinkedList.\");\n        } else {\n            let current = this.getHead();\n\n            if (index === 0 ) {\n                // this is the very first node\n                // remove (and update all positions)\n                this.setHead(current.next);\n            } else {\n                // iterate through all the nodes before the to be removed node.\n                // and set a pointer to the next node\n                let previous;\n                for (let i = 0; i < index; i++) {\n                    // temp store the one before\n                    previous = current;\n                    // go to the next node\n                    current = current.next;\n                }\n                // now let remove the reference of the previous node\n                // to skip it, and go to the next one.\n                previous.next = current.next;\n            }\n\n            this.total--;\n            isRemoved = true;\n        }\n        return isRemoved;\n    }\n\n    /**\n    * Return the total number of items from the stack\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @return number\n    */\n    size() {\n        // Note: in this example this.items.length would be wrong\n        // since we are removing values from the array\n        // the array is not shifting.\n        return this.total;\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    * @returns Boolean\n    */\n    isEmpty() {\n        return (this.total === 0);\n    }\n\n    /**\n    * Helper function to return an array\n    * of the LinkedList values.\n    *\n    * @return arr: Array\n    */\n    values(): any[] {\n        let arr = [];\n        if (this.getHead != null) {\n            let node = this.getHead();\n            for (let i = 0; i < this.size() && node != null; i++) {\n                arr.push(node);\n                // go to next node\n                node = node.next;\n            }\n        }\n        return arr;\n    }\n}\n","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Set.ts\");","/**\n * Set Data Structure\n * @class Set\n * @author Lee Boonstra\n *\n *      # What do we know about Sets?\n *      Set objects are collections of values.\n *      You can iterate through the elements of a set in insertion order.\n *      A value in the Set may only occur once; it is unique in the Set's collection.\n *      Because each value in the Set has to be unique, the value equality will be checked.\n *\n *      Since Set only contains distinct elements, it makes life much easier if we know in advance\n *      we want to avoid saving duplicate data to our structure.\n *      In Mathematics, it has concepts such as union, difference and intersection.\n *\n */\nexport class Set {\n    private items: Object;\n    private total: number;\n\n    constructor() {\n        this.items = {}; // note it's an object, so you can store only one key.\n        this.total = 0;\n    }\n\n    /**\n     * Check if the value exist. If not, add it to the set.\n     *\n     * @param  {string} element - String name value will be used as key and value\n     */\n    add(value: string) {\n        let isCreated = false;\n        if (!this.has(value)) {\n            this.items[this.total] = value;\n            isCreated = true;\n            this.total++;\n        }\n        return isCreated;\n    }\n\n    /**\n     * Remove value from the set\n     *\n     * @param {string} value - String name value will be used as key and value\n     */\n    delete(value: string) {\n        let isRemoved = false;\n        if (this.has(value)) {\n            delete this.items[value];\n            isRemoved = true;\n            this.total--;\n        }\n        return isRemoved;\n    }\n\n    /**\n     * Check if the value exist.\n     * Returns a boolean asserting whether an element is present with the given value in the Set object or not.\n     *\n     * @param {string} value - the value\n     * @return {boolean} isExisting - Boolean, returns true if value exists in Set.\n     */\n    has(value: string): Boolean {\n        let isExisting = false;\n        for (let key in this.items) {\n\n            if (this.items.hasOwnProperty(key)) {\n                 if (this.items[key] === value ) {\n                     if (parseInt(key) <= this.size()) {\n                        isExisting = true;\n                     }\n                 }\n            }\n        }\n        return isExisting;\n    }\n\n    /**\n     * Returns an array with all the keys of the Set\n     *\n     * @return {array} keys - Array with all the keys of the set\n     */\n    keys() {\n        let arr = [];\n        for (let item in this.items) {\n            arr.push(item)\n        }\n\n        return arr;\n    }\n\n    /**\n     * Returns an array with all the values of the Set\n     *\n     * @return {array} values - Array with all the values of the set\n     */\n    values() {\n        let arr = [];\n        for (let item in this.items) {\n            arr.push(this.items[item]);\n        }\n\n        return arr;\n    }\n\n    /**\n    * Removes all elements from the Set object.\n    */\n    clear(): void {\n        this.items = {};\n        this.total = 0;\n    }\n\n    /**\n    * Returns the number of values in the Set object.\n    *\n    * @return {number} total - Total amount of items in Set\n    */\n    size(): number {\n        return this.total;\n    }\n\n   /**\n    * Executes the callback function, for each item in the Set.\n    *\n    * @param {function} callback(key, val, set) - Callback function with 3 args key, value and set.\n    */\n    forEach(callback: Function) {\n        for (let key in this.items) {\n            callback(key, this.items[key], this.items);\n        }\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @returns {boolean} isEmpty - if the Stack is empty or not\n    */\n    isEmpty(): Boolean {\n        return (this.total === 0);\n    }\n\n    /**\n     * Given two sets, this returns a new set of elements from both of the given sets.\n     *\n     * @param {Set} otherSet - Another Set\n     * @return {Set} unionSet - Return a combined set.\n     */\n    union(otherSet: Set) {\n        let unionSet = new Set();\n\n        this.forEach(function(key: number, val: string, set: Set) {\n            unionSet.add(val)\n        });\n        otherSet.forEach(function(key: number, val: string, set: Set) {\n            unionSet.add(val)\n        });\n\n        return unionSet;\n    }\n\n    /**\n     * Given two sets, this returns a new set from elements that exist in both sets.\n     *\n     * @param {Set} otherSet - Another Set\n     * @return {Set} intersection - Return a intersection set.\n     */\n    intersection(otherSet: Set) {\n        let intersection = new Set();\n\n        this.forEach(function(key: number, val: string, set: Set) {\n            if (otherSet.has(val)) {\n                intersection.add(val);\n            }\n        });\n        return intersection;\n    }\n\n    /**\n     * Given two sets, this returns a new set with all the elements that\n     * exist in your set but not in the other set.\n     *\n     * @param {Set} otherSet - Another Set\n     * @return {Set} difference - Return a difference set.\n     */\n    difference(otherSet: Set) {\n        let difference = new Set();\n\n        this.forEach(function(key: number, val: string, set: Set) {\n            if (!otherSet.has(val)) {\n                difference.add(val);\n            }\n        });\n\n        return difference;\n    }\n\n    /**\n     * Given two sets, confirm with a boolean if this is a subset of another set.\n     *\n     * @param {Set} otherSet - Another Set\n     * @return {boolean} isSubset - Return boolean true if this is a subset.\n     */\n    isSubset(otherSet: Set) {\n        let isSubset = false;\n        let counter = 0;\n\n        // if this set is bigger than the other set, it can't be a subset\n        if (this.size() <= otherSet.size()) {\n            // loop through all items, and check if my values\n            // also exist in the other set.\n            // all values will need to exist.\n            this.forEach(function(key: number, val: string, set: Set) {\n                if (otherSet.has(val)) {\n                    counter++;\n                }\n            });\n        }\n\n        if (counter === this.size()) {\n            isSubset = true;\n        }\n\n        return isSubset;\n    }\n}\n","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Map.ts\");","/**\n * Map Data Structure\n * @class Map\n * @author Lee Boonstra\n *\n *      # What do we know about Map?\n *      Set objects are collections of key value pairs\n *      The key can be used to find a particular element.\n *      Other names are Dictionary, Symbol table or Associative Arrays\n *\n *      In computer science, maps are often used to store the refefence address of an object.\n *      For example, look in your Developer Tools, Memory tab and look at the Snapshots\n */\nexport class Map {\n    private items: Object;\n    private total: number;\n\n    constructor() {\n        this.items = {}; // note it's an object, so you can store only one key.\n        this.total = 0;\n    }\n\n    /**\n     * Check if the key exist. If not, add a key value pair\n     *\n     * @param  {string} key - String name key will be used as key and value\n     * @param  {string} value - String name value will be used as key and value\n     */\n    set(key: string, value: string) {\n        let isCreated = false;\n        if (!this.hasKey(key.toString())) {\n            this.items[key] = value;\n            isCreated = true;\n            this.total++;\n        }\n        return isCreated;\n    }\n\n    /**\n     * Remove value from the set\n     *\n     * @param  {string} key - String name key will be used as key and value\n     */\n    remove(key: string) {\n        let isRemoved = false;\n        if (this.hasKey(key.toString())) {\n            delete this.items[key];\n            isRemoved = true;\n            this.total--;\n        }\n        return isRemoved;\n    }\n\n    /**\n     * Check if the key exist.\n     * Returns a boolean asserting whether a key is present in the Map.\n     *\n     * @param {string} key - the key\n     * @return {boolean} isExisting - Boolean, returns true if value exists in Map.\n     */\n    hasKey(key: string): Boolean {\n        let isExisting = false;\n        if (this.items[key]) {\n            isExisting = true;\n        }\n        return isExisting;\n    }\n\n    /**\n     * Get the value from a specific key\n     *\n     * @param {string} key - the key\n     * @return {string} value - the value from the key\n     */\n    get(key: string): String {\n        return this.items[key.toString()];\n    }\n\n    /**\n     * Returns an array with all the keys of the Set\n     *\n     * @return {array} keys - Array with all the keys of the set\n     */\n    keys() {\n        let arr = [];\n        for (let item in this.items) {\n            arr.push(item)\n        }\n\n        return arr;\n    }\n\n    /**\n     * Returns an array with all the values of the Set\n     *\n     * @return {array} values - Array with all the values of the set\n     */\n    values() {\n        let arr = [];\n        for (let item in this.items) {\n            arr.push(this.items[item]);\n        }\n\n        return arr;\n    }\n\n    /**\n    * Removes all elements from the Set object.\n    */\n    clear(): void {\n        this.items = {};\n        this.total = 0;\n    }\n\n    /**\n    * Returns the number of values in the Set object.\n    *\n    * @return {number} total - Total amount of items in Set\n    */\n    size(): number {\n        return this.total;\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @returns {boolean} isEmpty - if the Stack is empty or not\n    */\n    isEmpty(): Boolean {\n        return (this.total === 0);\n    }\n\n\n   /**\n    * Executes the callback function, for each item in the Set.\n    *\n    * @param {function} callback(key, val, set) - Callback function with 3 args key, value and set.\n    */\n    forEach(callback: Function) {\n        for (let key in this.items) {\n            callback(key, this.items[key], this.items);\n        }\n    }\n}\n","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./HashTable.ts\");","import { SimpleDict } from './SimpleDict';\n\n/**\n * HashTable Data Structure\n * @class HashTable\n * @author Lee Boonstra\n *\n *      # What do we know about HashMap?\n *      Very similar to Maps/Associative Arrays, for storing\n *      key value pairs. You can find a stored value in the shortest\n *      time possible, O(1), rather than looping though each\n *      array value O(n) or using a sorted binary array\n *      or Tree O(log n).\n *\n *      Think about a student is assigned a student number\n *      that can be used to find information about him.\n *\n *      To make sure all key values in a HashTable are short\n *      as possible, and are integers to do fast lookup,\n *      we will need a hashing function.\n *      You will need to find a good hashing function, one\n *      that doesn't take too long to create a hash (when inserting/\n *      getting or removing). But you also don't want to make it\n *      to simple so you create collisions.\n *\n *      Although hash tables provide fast insertion, deletion, and retrieval,\n *      they perform poorly for operations that involve searching, such as finding the\n *      minimum and maximum values in a data set. For these operations, other data structures\n *      such as the binary search tree are more appropriate. Access and Deletion in worst case O(n)\n *\n *      ## Real world examples in Software Engineering?\n *      Browser vendors use hashtables a lot.\n *      But also when you use a database, you would set indexes to allow faster searching\n *\n */\nexport class HashTable {\n    private table: any[];\n    private total: number;\n    public bucketSize: number;\n    private probe: boolean;\n    private uniqueKeys: boolean;\n\n    /**\n     * @param {Object} opt - (optional)\n     * @param {boolean} opt.probe - enable probing default false\n     * @param {number} opt.bucketSize - if bucketSize set, create max HashTable buckets total. Less buckets is higher chance on collisions. Default 0, use good hashing function.\n     * @param {boolean} opt.uniqueKeys - skip duplicate key names so keys are unique default true\n     */\n    constructor(opt: any) {\n        this.table = [];\n        this.total = 0;\n        this.bucketSize = (opt.bucketSize || 0);\n        this.probe = (opt.probe || false);\n        this.uniqueKeys = (opt.uniqueKeys || true)\n    }\n\n    /**\n     * Check if the key exist. If not, add a key value pair\n     *\n     * @param  {string} key - String name key will be used as key and value\n     * @param  {string} value - String name value will be used as key and value\n     */\n    put(key: string, value: string) {\n        let isCreated = false;\n        let hash = this.hashCode(key);\n        if (!this.hasHash(hash)) {\n            this.table[hash] = new SimpleDict();\n            this.table[hash].set(key, value);\n            isCreated = true;\n            this.total++;\n        } else {\n            if (this.probe) {\n                let index = hash + 1;\n                while (this.table[index] !== undefined) {\n                    index++;\n                }\n                this.table[index] = new SimpleDict();\n                this.table[index].set(key, value);\n                isCreated = true;\n                this.total++;\n            } else {\n                // the hash already exists\n                if (this.uniqueKeys && this.table[hash].keys[0] === key) {\n                    // but the key is not unique\n                    // please skip duplicate\n                    console.error(key + ' already exists in HashTable, so skipped.');\n                } else {\n                    // now I want not a SimpleDict but an Array\n                    if (this.table[hash].constructor === SimpleDict) {\n                        let current = this.table[hash];\n                        this.table[hash] = []; // TODO or a LinkedList\n                        this.table[hash].push(current);\n                    }\n                    // its an array, add the new item\n                    let newItem = new SimpleDict();\n                    newItem.set(key, value);\n                    this.table[hash].push(newItem);\n                    isCreated = true;\n                    this.total++;\n                }\n            }\n        }\n\n        return isCreated;\n    }\n\n\n\n    /**\n     * Remove key value pair from the HashMap. When Collision with LinkedList is enabled, it will remove all occurences.\n     * When not probing best case O(1) worst case O(n).\n     *\n     * @param  {string} key - String name key will be used as key and value\n     */\n    remove(key: string) {\n        let isRemoved = false;\n        let hash = this.hashCode(key);\n        // when probing is enabled, and the table size doesn't match\n        // the bucket size, we will need to probe again to find\n        // the key back.\n        if (this.probe && (this.table.length !== this.bucketSize)) {\n            let index = hash;\n            // keep looping through you find the key\n            while (this.table[index].keys[0] !== key) {\n                index++;\n            }\n            this.table[index].remove(key);\n            isRemoved = true;\n            this.total--;\n        } else {\n            this.table[hash].remove(key);\n            isRemoved = true;\n            this.total--;\n        }\n\n        return isRemoved;\n    }\n\n    /**\n     * Check if the hash exist.\n     * Returns a boolean asserting whether a key is present in the Map.\n     *\n     * @param {number} hash - the hash\n     * @return {boolean} isExisting - Boolean, returns true if value exists in Map.\n     */\n    hasHash(hash: number): boolean {\n        let isExisting = false;\n        if (this.table[hash]) {\n            isExisting = true;\n        }\n        return isExisting;\n    }\n\n    /**\n     * Get the KeyValue Object pair from a specific key\n     * When not probing best case O(1) worst case O(n)\n     *\n     * @param {string} key - the key\n     * @return {Object | Array } return KeyValue Object or incase of LinkedList collision, an array with multiples.\n     */\n    get(key: string) {\n        let hash = this.hashCode(key);\n        let itemValue = undefined;\n\n        // when probing is enabled, and the table size doesn't match\n        // the bucket size, we will need to probe again to find\n        // the key back.\n        if (this.probe && (this.table.length !== this.bucketSize)) {\n            let index = hash;\n            // keep looping through you find the key\n            while (this.table[index].keys[0] !== key) {\n                index++;\n            }\n            itemValue = this.table[index].get(key);\n        } else {\n            if (this.table[hash].constructor === SimpleDict) {\n                itemValue = this.table[hash].get(key);\n            } else {\n                // there are multiples with this hash\n                // so we have to loop\n                let i = 0;\n                while (key !== this.table[hash][i].keys[0]) {\n                    i++;\n                }\n                itemValue = this.table[hash][i].get(key);\n            }\n        }\n\n        return itemValue;\n    }\n\n    /**\n    * Removes all elements from the Set object.\n    */\n    clear(): void {\n        this.table = [];\n        this.total = 0;\n    }\n\n    /**\n    * Returns the number of values in the Set object.\n    *\n    * @return {number} total - Total amount of items in Set\n    */\n    size(): number {\n        return this.total;\n    }\n\n    /**\n    * Check if the Stack is empty. Returns true if the stack has no items\n    * Take O(1) time. We do not run any loop in any of these operations.\n    *\n    * @returns {boolean} isEmpty - if the Stack is empty or not\n    */\n    isEmpty(): Boolean {\n        return (this.total === 0);\n    }\n\n   /**\n    * Executes the callback function, for each item in the Set.\n    *\n    * @param {function} callback(key, val, set) - Callback function with 3 args key, value and set.\n    */\n    forEach(callback: Function) {\n        for (let key in this.table) {\n            callback(key, this.table[key], this.table);\n        }\n    }\n\n    /**\n     * Create a hash based on a key string\n     * The Hash-function takes a key and converts it to a number which will be the index at which to store it.\n     * I am computing a hash value by summing the ASCII value of each character of the string\n     * , multiplying the ASCII value by a multiplier 'code', which in this case, is an odd prime 37.\n     * And the reason to choose 37 being, by some empirical research, if we take over 50,000 English words\n     * will produce less than 7 collisions in each case, while creating a hasing function.\n     *\n     * @param {string} key - the key\n     */\n    hashCode(key: string): number {\n        let hash = 0;\n        const code = 37;\n        for (let i = 0; i < key.length; i++) {\n          hash += code * hash + key.charCodeAt(i);\n        }\n        if (this.bucketSize !== 0) {\n            hash = hash % this.bucketSize;\n        }\n        return hash;\n    }\n}\n","/**\n * Simple Associative Array / Dictionary\n * @class SimpleDict\n * @author: Lee Boonstra\n *\n * A simple Associative Array / Matrix\n * Slow O(n)\n*/\nexport class SimpleDict {\n    private keys: any[];\n    private values: any[];\n    private total: number;\n\n    constructor() {\n        this.keys = [];\n        this.values = [];\n        this.total = 0;\n    }\n\n    /**\n    * Set key value pair in SimpleDict\n    * O(1)\n    * @param {string} key - the key value\n    * @param {any} value - the value\n    * @returns {Boolean} true if succesful created\n    */\n    set(key: string, value: any): Boolean {\n        this.keys.push(key);\n        this.values.push(value);\n        this.total++;\n\n        return true;\n    }\n\n    /**\n    * Remove key value pair in SimpleDict\n    * O(n)\n    * @param {string} key - the key value\n    * @returns {Boolean} true if succesful removed\n    */\n    remove(key: string): Boolean {\n        let isRemoved = false;\n        for (let i = 0; i < this.keys.length; i++) {\n            if (this.keys[i] === key) {\n                delete this.keys[i];\n                delete this.values[i];\n                this.total--;\n                isRemoved = true;\n            }\n        }\n        return isRemoved;\n    }\n\n    /**\n    * Get value from SimpleDict\n    * O(n)\n    * @param {string} key - the key value\n    * @returns {any} value - the value that belongs to the key\n    */\n    get(key: string): any {\n        for (let i = 0; i < this.keys.length; i++) {\n            if (this.keys[i] === key) {\n                return this.values[i];\n            }\n        }\n    }\n\n   /**\n     * Check if the key exist.\n     * Returns a boolean asserting whether a key is present in the Map.\n     *\n     * @param {string} key - the key\n     * @return {boolean} isExisting - Boolean, returns true if value exists in Map.\n     */\n    hasKey(key: string): Boolean {\n        return (this.get(key) ? true : false);\n    }\n\n    /**\n    * Get total size from SimpleDict\n    * O(1)\n    * @returns {number} total - the size of the SimpleDict\n    */\n    size(): number {\n        return this.total;\n    }\n\n    /**\n    * Checks if SimpleDict is empty\n    * O(1)\n    * @returns {boolean} isEmpty\n    */\n    isEmpty(): boolean {\n        return this.total === 0;\n    }\n\n    /**\n    * Clear the SimpleDict\n    * O(1)\n    * @returns {number} total - the size of the SimpleDict\n    */\n    clear(): number {\n        this.keys = [];\n        this.values = [];\n        this.total = 0;\n        return this.total;\n    }\n}","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Tree.ts\");","/**\n * TreeNode DataStructure\n * @class TreeNode\n * @author Lee Boonstra\n *\n */\nexport class TreeNode {\n    public key: number;\n    public left: TreeNode;\n    public right: TreeNode;\n\n    constructor(key: number, left: TreeNode = null, right: TreeNode = null) {\n        this.key = key;\n        this.left = left;\n        this.right = right\n    }\n}\n\n/**\n * Tree DataStructure\n * @class Tree\n * @author Lee Boonstra\n *\n *      # What do we know about Trees?\n *      A Tree is a non-linear data structure where data objects\n *      are organized in terms of hierarchical relationship.\n *      The structure is non-linear in the sense that,\n *      unlike simple array and linked list implementation,\n *      data in a tree is not organized linearly. Each data\n *      element is stored in a structure called a node.\n *\n *      Think about an organization chart of family tree.\n *\n *      ## BinarySearchTree (BST)\n *      A Node in a Tree can have multiple branches. In a BST\n *      the BST Node can only have 2 branches. One on the left,\n *      and one on the right. They are ordered. The left branch\n *      have values that are <= (lower or equal) than the parent node.\n *      The right branch has values that are => than the parent node.\n *      Therefore each lookup, insertion or deletion takes time\n *      in proporsional to the logarithm (log) of the number of the\n *      total items in the tree. (You can skip half of the tree).\n *      O(log n) instead of O(n) when sorting an array. However it is\n *      slower than the operations than a hashtable O(1).\n *\n *      ## Depth First Search (DFS)\n *\n *      ## Breadth First Search (BFS)\n *\n *      ## Real world examples in Software Engineering?\n *      DOM (Document Object Model)\n */\nexport class BinarySearchTree {\n    private root: TreeNode;\n\n    constructor() {\n        this.root = null;\n    }\n\n    // findMinNode()\n    // search(node, data)\n\n    /**\n     * Get the Root Node Value\n     * @returns {number | null} The Root Node Value\n     */\n    getRootNodeValue(): any {\n        let key = null;\n        if (this.root !== null) {\n            key = this.root.key;\n        }\n        return key;\n    }\n\n    /**\n     * Insert a node to a tree\n     * @param {number} key\n     */\n    insert(key: number) {\n        const node = this.root;\n        if (node == null) {\n            // this is the root node\n            // create a node based on this key\n            this.root = new TreeNode(key)\n            return;\n        } else {\n            // it's not the root node,\n            // so we will need to figure\n            // where to place this in the tree.\n            // let's use a recursive funciton\n            const searchTree = function(node: TreeNode): void {\n                // the key is smaller the parent node\n                if (key < node.key) {\n                    // when there are no nodes on the left side\n                    // we can start creating a node\n                    if (node.left == null) {\n                        // put it on the left side of the tree\n                        node.left = new TreeNode(key);\n                        return;\n                    } else if (node.left !== null) {\n                        // there are already nodes on the left\n                        // so we use a recursive function\n                        // passing in the node.left we just saw\n                        searchTree(node.left)\n                    }\n                } else if (key > node.key) {\n                    // when there are no nodes on the right side\n                    // we can start creating a node\n                    if (node.right == null) {\n                        // put it on the right side of the tree\n                        node.right = new TreeNode(key);\n                        return;\n                    } else if (node.right !== null) {\n                        // there are already nodes on the right\n                        // so we use a recursive function\n                        // passing in the node.right we just saw\n                        searchTree(node.right)\n                    } else {\n                        // the key must be equal. we won't add\n                        // it to the tree, we skip duplicates\n                        return null;\n                    }\n                }\n            }\n            // we will call the function\n            return searchTree(node);\n        }\n    }\n\n    /**\n     * This method returns the minimum value/key in the tree\n     */\n    min(): number {\n        let current = this.root;\n        // a while loop, continue searching\n        // till you are on the end of the left branch\n        while (current.left !== null && current.left !== undefined) {\n            current = current.left;\n        }\n        return current.key;\n    }\n\n    /**\n     * This method returns the maximum value/key in the tree\n     */\n    max(): number {\n        let current = this.root;\n        // a while loop, continue searching\n        // till you are on the end of the left branch\n        while (current.right != null) {\n            current = current.right;\n        }\n        return current.key;\n    }\n\n    /**\n     * This method searches for the key in the tree. It\n     * returns true if it exist and false if the node\n     * does not exist.\n     * @param {number} key - Key to search for\n     */\n    contains(key: number): boolean {\n        return (this.find(key) !== null)\n    }\n\n    /**\n     * This method searches for the key in the tree. It\n     * returns the TreeNode.\n     * @param {number} key - Key to search for\n     * @returns {TreeNode} - return node\n     */\n    find(key: number): TreeNode {\n        let current = this.root;\n        // when the current node is not null\n        while (current) {\n            // is it the current key?\n            if (key === current.key) {\n                // yep, found it\n                return current;\n            } else if (key < current.key) {\n                // value is lower than the parent\n                // let's look left\n                current = current.left;\n            } else {\n                // value is higher than the parent\n                // let's look right\n                current = current.right;\n            }\n            // haven't found it so continue looking\n        }\n        // we didn't find it, the key might be not in the tree\n        return null;\n    }\n\n    /**\n     * Removes a node in a tree.\n     * @param {number} data\n     */\n    remove(key: number) {\n        const removeNode = function(node: TreeNode, key: number): TreeNode {\n            if (node == null) {\n                // we have an empty tree\n                return null;\n            }\n            // can we find the data in the tree\n            if (key === node.key) {\n                // when the value is in the tree,\n                // there are 4 options:\n\n                // 1)\n                // node has no children, means its a leaf node\n                // we can just delete that node by setting\n                // the data of that node to null. (removing pointers)\n                if (node.left === null && node.right === null) {\n                    return null;\n                }\n\n                // 2)\n                // node has no left child\n                // we will replace pointers\n                // the parent node will get\n                // the right node from the to be deleted node\n                // as a new pointer\n                if (node.left === null) {\n                    return node.right;\n                }\n\n                // 3)\n                // node has no right child\n                // we will replace pointers\n                // the parent node will get\n                // the left node from the to be deleted node\n                // as a new pointer\n                if (node.right === null) {\n                    return node.left;\n                }\n\n                // 4)\n                // node has both children\n                // this is a bit more complicated\n                // cause you can't replace pointers\n                // of one, cause what would happen to the\n                // other child.\n\n                // we will first look to the right node\n                let tempNode = node.right;\n                // and find the min in the branch by\n                // looking all the way left\n                while (tempNode.left !== null) {\n                    tempNode = tempNode.left;\n                };\n                // the node that will need to be deleted\n                // gets the node data from the tempNode\n                // the one from all the way left\n                node.key = tempNode.key;\n\n                // and we will need to go back in this function\n                // again to make sure we re-link all the other\n                // pointers\n                node.right = removeNode(node.right, tempNode.key);\n                return node;\n            } else if (key < node.key) {\n                node.left = removeNode(node.left, key);\n                return node;\n            } else {\n                node.right = removeNode(node.right, key);\n                return node;\n            }\n        }\n        // call the recursive function, start with the root\n        this.root = removeNode(this.root, key);\n    }\n\n\n    /**\n     * Get the Tree Min Height\n     * Recursive Function\n     * @param {TreeNode} node - (default) rootNode\n     * @returns {number} minHeight - of the tree\n     */\n    getMinHeight(node = this.root): number {\n        if (node == null) {\n            // every time when you reach the leaf node\n            // return -1, so it's a number;\n            return -1;\n        }\n\n        // when node is not null, so it's not a leaf\n        // call this function again, passing in the\n        // previous node, that way you are walking\n        // through all the lefts, and all the rights.\n        let leftBranch = this.getMinHeight(node.left);\n        let rightBranch = this.getMinHeight(node.right);\n\n        // when the left branche is smaller\n        // start walking left, otherwise\n        // walk through the right branche\n        // and start counting (+1) till the end (null)\n\n        // the branch that's the smallest\n        // will contain the min height\n        if (leftBranch < rightBranch) {\n            return leftBranch + 1;\n        } else {\n            return rightBranch + 1;\n        }\n    }\n\n    /**\n     * Get the Tree Max Height\n     * @param {TreeNode} node - (default) rootNode\n     * @returns {number} maxHeight - of the tree\n     */\n    getMaxHeight(node = this.root): number {\n        if (node == null) {\n            // every time when you reach the leaf node\n            // return -1, so it's a number;\n            return -1;\n        }\n\n        // when node is not null, so it's not a leaf\n        // call this function again, passing in the\n        // previous node, that way you are walking\n        // through all the lefts, and all the rights.\n        let leftBranch = this.getMaxHeight(node.left);\n        let rightBranch = this.getMaxHeight(node.right);\n\n        // when the left branche is bigger\n        // start walking left, otherwise\n        // walk through the right branche\n        // and start counting (+1) till the end (null)\n\n        // the branch that's the biggest\n        // will contain the max height\n        if (leftBranch > rightBranch) {\n            return leftBranch + 1;\n        } else {\n            return rightBranch + 1;\n        }\n    }\n\n    /**\n     * Is Tree Balanced? A tree is balanced when the branches are equal or have 1 level difference.\n     * @returns {boolean} if the Tree is Balanced\n     */\n    isBalanced(): boolean {\n        return(this.getMinHeight()\n            >= this.getMaxHeight() - 1);\n    }\n\n    /**\n     * Traverse the tree\n     * @param {object} opt\n     * @param {string} opt.method - inOrder | preOrder | postOrder | levelOrder (default inOrder); \n     * @returns {array} - sorted array\n     */\n    traverse(opt: any): any {\n        let array = new Array();\n        let method = \"\";\n        if (opt.method) {\n            method = opt.method.toLowerCase();\n        }\n        console.log(method);\n        switch (method) {\n            case \"inorder\":\n                array = this.inorder();\n                break;\n            case \"preorder\":\n                array = this.preorder();\n                break;\n            case \"postorder\":\n                array = this.postorder();\n                break;\n            case \"levelorder\":\n                array = this.levelorder();\n                break;\n            default:\n                array = this.inorder();\n        }\n\n        return array;\n    }\n\n    /**\n     * Traverses nodes of a tree with DFS\n     * @returns {array} - return an inorder array\n     */\n    inorder(): any[] {\n        if (this.root == null) {\n            // check if there's a BST\n            // and if there are values\n            // in it\n            console.log(\"root = null\");\n            return null;\n        } else {\n            let result = new Array();\n            // recursive function\n            function traverseInOrder(node: TreeNode) {\n                // we start from the root node.\n\n                // if the current node has a node.left\n                // then call this function\n                // again but pass in the left node\n                // else ignore\n                // if (node.left) console.log(\"execute if node \" + node.key + \" has a left: \" + node.left.key);\n                node.left && traverseInOrder(node.left);\n\n                // and then add the value to the array\n                // so for everytime you called the \n                // function, you still will add values\n                // to the array\n                // console.log(\"push in array \" + node.key);\n                result.push(node.key);\n\n                // next, check if the current node has\n                // a right node. else ignore\n                // in case not, go up\n                // pass that node to the array\n\n                // if node.right does exist call this function\n                // again but pass in the right node\n                // if (node.right) console.log(\"execute if node \" + node.key + \" has a right: \" + node.right.key);\n                node.right && traverseInOrder(node.right);\n            }\n            traverseInOrder(this.root);\n            return result;\n        }\n    }\n\n    /**\n     * Traverses nodes of a tree with BFS\n     * @returns {array} - return an preorder array\n     */\n    preorder(): any[] {\n        if (this.root == null) {\n            // check if there's a BST\n            // and if there are values\n            // in it\n            return null;\n        } else {\n            let result = new Array();\n            // recursive function\n            function traversePreOrder(node: TreeNode) {\n                // add the key in the results array\n                result.push(node.key);\n                // if node.left exist call this function\n                // again but pass in the left node\n                node.left && traversePreOrder(node.left);\n                // if node.right exist call this function\n                // again but pass in the right node\n                node.right && traversePreOrder(node.right);\n            }\n            traversePreOrder(this.root);\n            return result;\n        }\n    }\n\n    /**\n     * Traverses nodes of a tree with BFS\n     * @returns {array} - return an postorder array\n     */\n    postorder(): any[] {\n        if (this.root == null) {\n            // check if there's a BST\n            // and if there are values\n            // in it\n            return null;\n        } else {\n            let result = new Array();\n            // recursive function\n            function traversePostOrder(node: TreeNode) {\n                // if node.left exist call this function\n                // again but pass in the left node\n                node.left && traversePostOrder(node.left);\n                // if node.right exist call this function\n                // again but pass in the right node\n                node.right && traversePostOrder(node.right);\n                // add the key in the results array\n                result.push(node.key);\n            }\n            traversePostOrder(this.root);\n            return result;\n        }\n    }\n\n    /**\n     * Traverses nodes for each level\n     * @returns {array} - return an level order array\n     */\n    levelorder(): any {\n        let results = [];\n        let queue = [];\n        if (this.root != null) {\n            queue.push(this.root);\n            // now we will loop\n            // as long as there are\n            // items in the queue\n            while (queue.length > 0) {\n                let node = queue.shift();\n                // takes the first element in the\n                // array and remove that element\n                // so we will start with the rootnode\n                // in the queue. and after shifting\n                // it's not in the queue anymore\n\n                // we can put the key in the results array\n                results.push(node.key);\n\n                if (node.left != null) {\n                    // console.log(node.key + \" has a left node: \" + node.left.key)\n                    // when there is a left node\n                    // we can put it to the queue\n                    // so the while loop won't stop\n                    queue.push(node.left);\n                }\n                if (node.right != null) {\n                    // console.log(node.key + \" has a right node: \" + node.right.key)\n            \n                    // when there is a right node\n                    // we can put it to the queue\n                    // so the while loop won't stop\n                    queue.push(node.right);\n                }\n\n                // when there are items in the queue,\n                // we can start adding it to the results\n                // array, and start checking for the next\n                // level.\n            }\n            return results;\n        } else {\n            return null;\n        }\n    }\n}","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Graph.ts\");","import { Queue } from '../datastructures/Queue';\nimport { Stack } from '../datastructures/Stack';\nimport { SimpleDict } from '../datastructures/SimpleDict';\n\n/**\n * Each node object  / Vertex\n * @class GraphNode\n * @author Lee Boonstra\n * @param {string} id - string with the node id\n */\nexport class GraphNode {\n    public id: string;\n    public adjacents: Array<string>;\n\n    constructor(id: string) {\n        this.id = id;\n        this.adjacents = new Array();\n    }\n}\n\n/**\n * Create a Graph\n * @class Graph\n * @author Lee Boonstra\n * @param {array} nodeIds - An array with all the string ids to be created\n * @param {array} matrix - A 2 dimensional array (matrix), used as an adjacency list\n */\nexport class Graph {\n    private vertices: Object;\n    private nodeIds: any[];\n    public matrix: any[];\n\n    constructor (nodeIds: Array<string>, matrix: any) {\n        this.matrix = matrix;\n        this.nodeIds = nodeIds;\n        this.vertices = {};\n\n        // the matrix should have for each row a vertex\n        if (nodeIds.length !== this.matrix.length) {\n            throw \"The size of the matrix doesn't contain the total of vertices\";\n        }\n\n        // loop through the array rows\n        for (let i = 0; i < matrix.length; i++) {\n            // create a vertex node, for each row in the matrix\n            let node = new GraphNode(this.nodeIds[i]);\n\n            // loop through all the adjacents\n            for (let j = 0; j < this.matrix[i].length; j++) {\n                // Add the adjacent, when it's marked\n                // as one in the matrix.\n                if (matrix[i][j] === 1) {\n                    node.adjacents.push(this.nodeIds[j]);\n                }\n            }\n\n            // each vertex gets a row in the vertices array\n            this.vertices[node.id] = node;\n        }\n\n        console.log(this.vertices);\n    }\n\n\n\n    /**\n     * Get the Node that belongs to a particular node id.\n     * @param {number} nodeId - Node id to look for\n     * @returns {Node} node - The matching node\n     */\n    getNode(nodeId: string): GraphNode {\n        return this.vertices[nodeId];\n    }\n\n    addNode() {\n\n\n\n\n    }\n\n    addEdge() {\n\n    }\n\n   /**\n     * Log Breadth First Path from one node to another\n     * Go wide, and first check all neighbor nodes. (adjacents) before going deep.\n     * @param {string} startId - The Node Id to start searching from\n     * @param {string} destinationId - The Node Id that needs to be found\n     * @returns {array} history - return a DFS array\n     */\n    public getBfsPath(startId: string, destinationId: string): Array<string> {\n        let history = [];\n        let source = this.getNode(startId);\n        let destination = this.getNode(destinationId);\n        let visited = new SimpleDict();\n\n        history = this._bfs(source, destination, visited);\n        if (history === false) {\n            history = [];\n        }\n        return history;\n    }\n\n    /**\n     * Log Depth First Path from one node to another\n     * Go deep into nodes, before exploring other nodes.\n     * @param {string} startId - The Node Id to start searching from\n     * @param {string} destinationId = The Node Id that needs to be found\n     * @returns {array} history - return a DFS array\n     */\n    public getDfsPath (startId: string, destinationId: string): Array<string> {\n        let history = [];\n        let source = this.getNode(startId);\n        let destination = this.getNode(destinationId);\n        let visited = new SimpleDict();\n\n        history = this._dfs(source, destination, visited);\n        if (history === false) {\n            history = [];\n        }\n        return history;\n    }\n\n    /**\n     * Check if Path exist via Depth First Search\n     * Go deep into nodes, before exploring other nodes.\n     * Using a Stack\n     * @param {string} startId - The Node Id to start searching from\n     * @param {string} destinationId - The Node Id that needs to be found\n     * @returns {boolean} pathExists - return true if a path was found\n     */\n    public hasPathDfs(startId: string, destinationId: string): boolean {\n        let pathExists = false;\n        let source = this.getNode(startId);\n        let destination = this.getNode(destinationId);\n        let visited = new SimpleDict();\n\n        pathExists = this._dfs(source, destination, visited);\n        return (pathExists !== false);\n    }\n\n    /**\n     * Check if Path exist via Breath First Search\n     * Go wide, and first check all neighbor nodes. (adjacents) before going deep.\n     * Using a Queue\n     * @param {string} startId - The Node Id to start searching from\n     * @param {string} destinationId - The Node Id that needs to be found\n     * @returns {boolean} pathExists - return true if a path was found\n     */\n    public hasPathBfs(startId: string, destinationId: string): boolean {\n        let pathExists = false;\n        let source = this.getNode(startId);\n        let destination = this.getNode(destinationId);\n        let visited = new SimpleDict();\n\n        pathExists = this._bfs(source, destination, visited);\n\n        return (pathExists !== false);\n    }\n\n\n   /**\n     * Check if Path exist via Depth First Search\n     * Go deep into nodes, before exploring other nodes.\n     * Using Stacks\n     * @param {GraphNode} source - The Node to start searching from\n     * @param {GraphNode} destination - The Node that needs to be found\n     * @param {SimpleDict} visited - A Simple Dictionary holding the references to the visisted vertices\n     * @returns {boolean} pathExists - return true if a path was found\n     */\n    private _dfs(source: GraphNode, destination: GraphNode, visited: SimpleDict): any {\n        let stack = new Stack();\n        let history = [];\n        stack.push(source);\n\n        while (!stack.isEmpty()) {\n            // as long as there are items in the queue\n            // keep running this\n\n            // get the item from the queue\n            let node = stack.pop();\n\n            // console.log(node.id);\n\n            // the node you are looking for\n            // is the same as the destination\n            if (node === destination) {\n                history.push(node.id);\n                // path of all visited\n                return history;\n            }\n\n            if (visited.hasKey(node.id)) {\n                // you have visited the node before\n                // the continue statement \"jumps over\" one iteration in the loop.\n                continue;\n            } else {\n                history.push(node.id);\n            }\n\n            visited.set(node.id, true);\n\n            // now look into its adjacents\n            for (let id of node.adjacents) {\n                let neighbor = this.getNode(id);\n                stack.push(neighbor);\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if Path exist via Breath First Search\n     * Go wide, and first check all neighbor nodes. (adjacents) before going deep.\n     * Need a Queue for this\n     * @param {GraphNode} source - The Node to start searching from\n     * @param {GraphNode} destination - The Node that needs to be found\n     * @param {SimpleDict} visited - A Simple Dictionary holding the references to the visisted vertices\n     * @returns {boolean} pathExists - return true if a path was found\n     */\n    private _bfs(source: GraphNode, destination: GraphNode, visited: SimpleDict): any {\n        let queue = new Queue();\n        let history = [];\n        queue.add(source);\n\n        while (!queue.isEmpty()) {\n            // as long as there are items in the queue\n            // keep running this\n\n            // get the item from the queue\n            let node = queue.remove();\n\n            // console.log(node.id);\n\n            // the node you are looking for\n            // is the same as the destination\n            if (node === destination) {\n                history.push(node.id);\n                // path of all visited\n                return history;\n            }\n\n            if (visited.hasKey(node.id)) {\n                // you have visited the node before\n                // the continue statement \"jumps over\" one iteration in the loop.\n                continue;\n            } else {\n                    history.push(node.id);\n            }\n\n            visited.set(node.id, true);\n\n            // now look into its adjacents\n            for (let id of node.adjacents) {\n                let neighbor = this.getNode(id);\n                queue.add(neighbor);\n            }\n        }\n\n        return false;\n    }\n}\n","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./Sorters.ts\");","/**\n * Array Sorters\n * @class Sorters\n * @author Lee Boonstra\n */\nexport class Sorters {\n\n    public quicksort(array: Array<number>): Array<number> {\n        return this._quicksort(array, 0, array.length - 1);\n    }\n\n    private _quicksort(array: Array<number>, leftPos: number, rightPos: number): Array<number> {\n        if (leftPos === rightPos) {\n            console.log(array);\n            return array;\n        }\n        // let pivot = array[Math.ceil(array.length / 2)];\n        let pivot = rightPos;\n        let index = this._partition(array, leftPos, rightPos, pivot);\n\n        this._quicksort(array, leftPos, index - 1);\n        this._quicksort(array, index, rightPos);\n    }\n\n    private _partition(array: Array<number>, leftPos: number, rightPos: number, pivot: number): number {\n        console.log(array);\n        while (leftPos <= rightPos) {\n         // we will loop through all the items, bringing the\n         // leftPos and the rightPos closer\n\n            while (array[leftPos] < array[pivot]) {\n                leftPos++;\n            }\n\n            while (array[rightPos] > array[pivot]) {\n                rightPos--;\n            }\n\n            if (leftPos < rightPos) {\n                this._swap(array, leftPos, rightPos);\n                leftPos++;\n                rightPos--;\n            } else {\n                return leftPos;\n            }\n\n        }\n\n        return leftPos;\n    }\n\n    private _swap(array: Array<number>, leftPos: number, rightPos: number) {\n        let temp = array[leftPos];\n        array[leftPos] = array[rightPos];\n        array[rightPos] = temp;\n    }\n}","module.exports = global[\"Library\"] = require(\"-!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/awesome-typescript-loader/dist/entry.js!/Users/leeboonstra/Documents/GitHub/js-datastructures-algorithms/node_modules/source-map-loader/index.js!./TwoStrings.ts\");","export class SubStringSet {\n    private items: Object;\n\n    constructor() {\n        this.items = {};\n    }\n\n    /**\n     * Add a string to the set, can not be duplicate\n\t * @param {string} value - a string character\n\t * returns {Boolean} isAdded - if value has been added to the set.\n     */\n    add(value: string): Boolean {\n        let isExist = false;\n        // TODO do a check on space.\n        if (!this.has(value)) {\n            this.items[value] = value;\n        }\n        return isExist;\n    }\n\n    /**\n     * Check if value exist in the Set\n     * @param {string} value - a string character\n     * returns {Boolean} exists - true if value exists in Set\n     */\n    has(value: string): Boolean {\n        let exists = false;\n        if (this.items.hasOwnProperty(value)) {\n            exists = true;\n        }\n        return exists;\n    }\n\n\n    /**\n      * Return a new set with all the common values\n      * @param {Set} otherSet - the otherSet to check on\n      * @returns {Set} newSet - set with similarities\n      */\n      intersection(otherSet: SubStringSet): SubStringSet {\n        let newSet = new SubStringSet();\n\n        for (let myVal in otherSet.items) {\n            if (this.has(myVal)) {\n                newSet.add(myVal);\n            }\n        }\n\n        return newSet;\n      }\n}\n"],"sourceRoot":""}